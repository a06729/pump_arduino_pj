
freeRtos_uart.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800100  0000169c  00001730  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000169c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000004e0  00800116  00800116  00001746  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001746  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001778  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000388  00000000  00000000  000017b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000404d  00000000  00000000  00001b40  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000010e6  00000000  00000000  00005b8d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002493  00000000  00000000  00006c73  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b10  00000000  00000000  00009108  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000013cb  00000000  00000000  00009c18  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003b27  00000000  00000000  0000afe3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003b8  00000000  00000000  0000eb0a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 73 02 	jmp	0x4e6	; 0x4e6 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 69 0a 	jmp	0x14d2	; 0x14d2 <__vector_18>
      4c:	0c 94 99 0a 	jmp	0x1532	; 0x1532 <__vector_19>
      50:	0c 94 cb 0a 	jmp	0x1596	; 0x1596 <__vector_20>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ec e9       	ldi	r30, 0x9C	; 156
      7c:	f6 e1       	ldi	r31, 0x16	; 22
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a6 31       	cpi	r26, 0x16	; 22
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	25 e0       	ldi	r18, 0x05	; 5
      8c:	a6 e1       	ldi	r26, 0x16	; 22
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a6 3f       	cpi	r26, 0xF6	; 246
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 3d 0a 	call	0x147a	; 0x147a <main>
      9e:	0c 94 4c 0b 	jmp	0x1698	; 0x1698 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
      ac:	0e 94 e5 06 	call	0xdca	; 0xdca <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
      b0:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <__data_end>
      b4:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <__data_end+0x1>
      b8:	89 2b       	or	r24, r25
      ba:	31 f4       	brne	.+12     	; 0xc8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
      bc:	8b e1       	ldi	r24, 0x1B	; 27
      be:	91 e0       	ldi	r25, 0x01	; 1
      c0:	90 93 17 01 	sts	0x0117, r25	; 0x800117 <__data_end+0x1>
      c4:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
      c8:	20 91 18 01 	lds	r18, 0x0118	; 0x800118 <xNextFreeByte>
      cc:	30 91 19 01 	lds	r19, 0x0119	; 0x800119 <xNextFreeByte+0x1>
      d0:	c9 01       	movw	r24, r18
      d2:	8c 0f       	add	r24, r28
      d4:	9d 1f       	adc	r25, r29
      d6:	8f 31       	cpi	r24, 0x1F	; 31
      d8:	43 e0       	ldi	r20, 0x03	; 3
      da:	94 07       	cpc	r25, r20
      dc:	70 f4       	brcc	.+28     	; 0xfa <pvPortMalloc+0x54>
      de:	28 17       	cp	r18, r24
      e0:	39 07       	cpc	r19, r25
      e2:	70 f4       	brcc	.+28     	; 0x100 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
      e4:	c0 91 16 01 	lds	r28, 0x0116	; 0x800116 <__data_end>
      e8:	d0 91 17 01 	lds	r29, 0x0117	; 0x800117 <__data_end+0x1>
      ec:	c2 0f       	add	r28, r18
      ee:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
      f0:	90 93 19 01 	sts	0x0119, r25	; 0x800119 <xNextFreeByte+0x1>
      f4:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <xNextFreeByte>
      f8:	05 c0       	rjmp	.+10     	; 0x104 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
      fa:	c0 e0       	ldi	r28, 0x00	; 0
      fc:	d0 e0       	ldi	r29, 0x00	; 0
      fe:	02 c0       	rjmp	.+4      	; 0x104 <pvPortMalloc+0x5e>
     100:	c0 e0       	ldi	r28, 0x00	; 0
     102:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     104:	0e 94 a5 07 	call	0xf4a	; 0xf4a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     108:	ce 01       	movw	r24, r28
     10a:	df 91       	pop	r29
     10c:	cf 91       	pop	r28
     10e:	08 95       	ret

00000110 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     110:	08 95       	ret

00000112 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     112:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     114:	03 96       	adiw	r24, 0x03	; 3
     116:	92 83       	std	Z+2, r25	; 0x02
     118:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     11a:	2f ef       	ldi	r18, 0xFF	; 255
     11c:	3f ef       	ldi	r19, 0xFF	; 255
     11e:	34 83       	std	Z+4, r19	; 0x04
     120:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     122:	96 83       	std	Z+6, r25	; 0x06
     124:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     126:	90 87       	std	Z+8, r25	; 0x08
     128:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     12a:	10 82       	st	Z, r1
     12c:	08 95       	ret

0000012e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     12e:	fc 01       	movw	r30, r24
     130:	11 86       	std	Z+9, r1	; 0x09
     132:	10 86       	std	Z+8, r1	; 0x08
     134:	08 95       	ret

00000136 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     136:	cf 93       	push	r28
     138:	df 93       	push	r29
     13a:	9c 01       	movw	r18, r24
     13c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     13e:	dc 01       	movw	r26, r24
     140:	11 96       	adiw	r26, 0x01	; 1
     142:	cd 91       	ld	r28, X+
     144:	dc 91       	ld	r29, X
     146:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     148:	d3 83       	std	Z+3, r29	; 0x03
     14a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     14c:	8c 81       	ldd	r24, Y+4	; 0x04
     14e:	9d 81       	ldd	r25, Y+5	; 0x05
     150:	95 83       	std	Z+5, r25	; 0x05
     152:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     154:	8c 81       	ldd	r24, Y+4	; 0x04
     156:	9d 81       	ldd	r25, Y+5	; 0x05
     158:	dc 01       	movw	r26, r24
     15a:	13 96       	adiw	r26, 0x03	; 3
     15c:	7c 93       	st	X, r23
     15e:	6e 93       	st	-X, r22
     160:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     162:	7d 83       	std	Y+5, r23	; 0x05
     164:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     166:	31 87       	std	Z+9, r19	; 0x09
     168:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     16a:	f9 01       	movw	r30, r18
     16c:	80 81       	ld	r24, Z
     16e:	8f 5f       	subi	r24, 0xFF	; 255
     170:	80 83       	st	Z, r24
}
     172:	df 91       	pop	r29
     174:	cf 91       	pop	r28
     176:	08 95       	ret

00000178 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     178:	cf 93       	push	r28
     17a:	df 93       	push	r29
     17c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     17e:	48 81       	ld	r20, Y
     180:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     182:	4f 3f       	cpi	r20, 0xFF	; 255
     184:	2f ef       	ldi	r18, 0xFF	; 255
     186:	52 07       	cpc	r21, r18
     188:	21 f4       	brne	.+8      	; 0x192 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     18a:	fc 01       	movw	r30, r24
     18c:	a7 81       	ldd	r26, Z+7	; 0x07
     18e:	b0 85       	ldd	r27, Z+8	; 0x08
     190:	0d c0       	rjmp	.+26     	; 0x1ac <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     192:	dc 01       	movw	r26, r24
     194:	13 96       	adiw	r26, 0x03	; 3
     196:	01 c0       	rjmp	.+2      	; 0x19a <vListInsert+0x22>
     198:	df 01       	movw	r26, r30
     19a:	12 96       	adiw	r26, 0x02	; 2
     19c:	ed 91       	ld	r30, X+
     19e:	fc 91       	ld	r31, X
     1a0:	13 97       	sbiw	r26, 0x03	; 3
     1a2:	20 81       	ld	r18, Z
     1a4:	31 81       	ldd	r19, Z+1	; 0x01
     1a6:	42 17       	cp	r20, r18
     1a8:	53 07       	cpc	r21, r19
     1aa:	b0 f7       	brcc	.-20     	; 0x198 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     1ac:	12 96       	adiw	r26, 0x02	; 2
     1ae:	ed 91       	ld	r30, X+
     1b0:	fc 91       	ld	r31, X
     1b2:	13 97       	sbiw	r26, 0x03	; 3
     1b4:	fb 83       	std	Y+3, r31	; 0x03
     1b6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     1b8:	d5 83       	std	Z+5, r29	; 0x05
     1ba:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     1bc:	bd 83       	std	Y+5, r27	; 0x05
     1be:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     1c0:	13 96       	adiw	r26, 0x03	; 3
     1c2:	dc 93       	st	X, r29
     1c4:	ce 93       	st	-X, r28
     1c6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     1c8:	99 87       	std	Y+9, r25	; 0x09
     1ca:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     1cc:	fc 01       	movw	r30, r24
     1ce:	20 81       	ld	r18, Z
     1d0:	2f 5f       	subi	r18, 0xFF	; 255
     1d2:	20 83       	st	Z, r18
}
     1d4:	df 91       	pop	r29
     1d6:	cf 91       	pop	r28
     1d8:	08 95       	ret

000001da <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     1da:	cf 93       	push	r28
     1dc:	df 93       	push	r29
     1de:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     1e0:	a0 85       	ldd	r26, Z+8	; 0x08
     1e2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     1e4:	c2 81       	ldd	r28, Z+2	; 0x02
     1e6:	d3 81       	ldd	r29, Z+3	; 0x03
     1e8:	84 81       	ldd	r24, Z+4	; 0x04
     1ea:	95 81       	ldd	r25, Z+5	; 0x05
     1ec:	9d 83       	std	Y+5, r25	; 0x05
     1ee:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     1f0:	c4 81       	ldd	r28, Z+4	; 0x04
     1f2:	d5 81       	ldd	r29, Z+5	; 0x05
     1f4:	82 81       	ldd	r24, Z+2	; 0x02
     1f6:	93 81       	ldd	r25, Z+3	; 0x03
     1f8:	9b 83       	std	Y+3, r25	; 0x03
     1fa:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     1fc:	11 96       	adiw	r26, 0x01	; 1
     1fe:	8d 91       	ld	r24, X+
     200:	9c 91       	ld	r25, X
     202:	12 97       	sbiw	r26, 0x02	; 2
     204:	e8 17       	cp	r30, r24
     206:	f9 07       	cpc	r31, r25
     208:	31 f4       	brne	.+12     	; 0x216 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     20a:	84 81       	ldd	r24, Z+4	; 0x04
     20c:	95 81       	ldd	r25, Z+5	; 0x05
     20e:	12 96       	adiw	r26, 0x02	; 2
     210:	9c 93       	st	X, r25
     212:	8e 93       	st	-X, r24
     214:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     216:	11 86       	std	Z+9, r1	; 0x09
     218:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     21a:	8c 91       	ld	r24, X
     21c:	81 50       	subi	r24, 0x01	; 1
     21e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     220:	df 91       	pop	r29
     222:	cf 91       	pop	r28
     224:	08 95       	ret

00000226 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     226:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     22a:	89 ef       	ldi	r24, 0xF9	; 249
     22c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
     230:	e1 e8       	ldi	r30, 0x81	; 129
     232:	f0 e0       	ldi	r31, 0x00	; 0
     234:	80 81       	ld	r24, Z
     236:	8b 60       	ori	r24, 0x0B	; 11
     238:	80 83       	st	Z, r24
     23a:	ef e6       	ldi	r30, 0x6F	; 111
     23c:	f0 e0       	ldi	r31, 0x00	; 0
     23e:	80 81       	ld	r24, Z
     240:	82 60       	ori	r24, 0x02	; 2
     242:	80 83       	st	Z, r24
     244:	08 95       	ret

00000246 <pxPortInitialiseStack>:
     246:	31 e1       	ldi	r19, 0x11	; 17
     248:	fc 01       	movw	r30, r24
     24a:	30 83       	st	Z, r19
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	22 e2       	ldi	r18, 0x22	; 34
     250:	20 83       	st	Z, r18
     252:	31 97       	sbiw	r30, 0x01	; 1
     254:	a3 e3       	ldi	r26, 0x33	; 51
     256:	a0 83       	st	Z, r26
     258:	31 97       	sbiw	r30, 0x01	; 1
     25a:	60 83       	st	Z, r22
     25c:	31 97       	sbiw	r30, 0x01	; 1
     25e:	70 83       	st	Z, r23
     260:	31 97       	sbiw	r30, 0x01	; 1
     262:	10 82       	st	Z, r1
     264:	31 97       	sbiw	r30, 0x01	; 1
     266:	60 e8       	ldi	r22, 0x80	; 128
     268:	60 83       	st	Z, r22
     26a:	31 97       	sbiw	r30, 0x01	; 1
     26c:	10 82       	st	Z, r1
     26e:	31 97       	sbiw	r30, 0x01	; 1
     270:	62 e0       	ldi	r22, 0x02	; 2
     272:	60 83       	st	Z, r22
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	63 e0       	ldi	r22, 0x03	; 3
     278:	60 83       	st	Z, r22
     27a:	31 97       	sbiw	r30, 0x01	; 1
     27c:	64 e0       	ldi	r22, 0x04	; 4
     27e:	60 83       	st	Z, r22
     280:	31 97       	sbiw	r30, 0x01	; 1
     282:	65 e0       	ldi	r22, 0x05	; 5
     284:	60 83       	st	Z, r22
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	66 e0       	ldi	r22, 0x06	; 6
     28a:	60 83       	st	Z, r22
     28c:	31 97       	sbiw	r30, 0x01	; 1
     28e:	67 e0       	ldi	r22, 0x07	; 7
     290:	60 83       	st	Z, r22
     292:	31 97       	sbiw	r30, 0x01	; 1
     294:	68 e0       	ldi	r22, 0x08	; 8
     296:	60 83       	st	Z, r22
     298:	31 97       	sbiw	r30, 0x01	; 1
     29a:	69 e0       	ldi	r22, 0x09	; 9
     29c:	60 83       	st	Z, r22
     29e:	31 97       	sbiw	r30, 0x01	; 1
     2a0:	60 e1       	ldi	r22, 0x10	; 16
     2a2:	60 83       	st	Z, r22
     2a4:	31 97       	sbiw	r30, 0x01	; 1
     2a6:	30 83       	st	Z, r19
     2a8:	31 97       	sbiw	r30, 0x01	; 1
     2aa:	32 e1       	ldi	r19, 0x12	; 18
     2ac:	30 83       	st	Z, r19
     2ae:	31 97       	sbiw	r30, 0x01	; 1
     2b0:	33 e1       	ldi	r19, 0x13	; 19
     2b2:	30 83       	st	Z, r19
     2b4:	31 97       	sbiw	r30, 0x01	; 1
     2b6:	34 e1       	ldi	r19, 0x14	; 20
     2b8:	30 83       	st	Z, r19
     2ba:	31 97       	sbiw	r30, 0x01	; 1
     2bc:	35 e1       	ldi	r19, 0x15	; 21
     2be:	30 83       	st	Z, r19
     2c0:	31 97       	sbiw	r30, 0x01	; 1
     2c2:	36 e1       	ldi	r19, 0x16	; 22
     2c4:	30 83       	st	Z, r19
     2c6:	31 97       	sbiw	r30, 0x01	; 1
     2c8:	37 e1       	ldi	r19, 0x17	; 23
     2ca:	30 83       	st	Z, r19
     2cc:	31 97       	sbiw	r30, 0x01	; 1
     2ce:	38 e1       	ldi	r19, 0x18	; 24
     2d0:	30 83       	st	Z, r19
     2d2:	31 97       	sbiw	r30, 0x01	; 1
     2d4:	39 e1       	ldi	r19, 0x19	; 25
     2d6:	30 83       	st	Z, r19
     2d8:	31 97       	sbiw	r30, 0x01	; 1
     2da:	30 e2       	ldi	r19, 0x20	; 32
     2dc:	30 83       	st	Z, r19
     2de:	31 97       	sbiw	r30, 0x01	; 1
     2e0:	31 e2       	ldi	r19, 0x21	; 33
     2e2:	30 83       	st	Z, r19
     2e4:	31 97       	sbiw	r30, 0x01	; 1
     2e6:	20 83       	st	Z, r18
     2e8:	31 97       	sbiw	r30, 0x01	; 1
     2ea:	23 e2       	ldi	r18, 0x23	; 35
     2ec:	20 83       	st	Z, r18
     2ee:	31 97       	sbiw	r30, 0x01	; 1
     2f0:	40 83       	st	Z, r20
     2f2:	31 97       	sbiw	r30, 0x01	; 1
     2f4:	50 83       	st	Z, r21
     2f6:	31 97       	sbiw	r30, 0x01	; 1
     2f8:	26 e2       	ldi	r18, 0x26	; 38
     2fa:	20 83       	st	Z, r18
     2fc:	31 97       	sbiw	r30, 0x01	; 1
     2fe:	27 e2       	ldi	r18, 0x27	; 39
     300:	20 83       	st	Z, r18
     302:	31 97       	sbiw	r30, 0x01	; 1
     304:	28 e2       	ldi	r18, 0x28	; 40
     306:	20 83       	st	Z, r18
     308:	31 97       	sbiw	r30, 0x01	; 1
     30a:	29 e2       	ldi	r18, 0x29	; 41
     30c:	20 83       	st	Z, r18
     30e:	31 97       	sbiw	r30, 0x01	; 1
     310:	20 e3       	ldi	r18, 0x30	; 48
     312:	20 83       	st	Z, r18
     314:	31 97       	sbiw	r30, 0x01	; 1
     316:	21 e3       	ldi	r18, 0x31	; 49
     318:	20 83       	st	Z, r18
     31a:	86 97       	sbiw	r24, 0x26	; 38
     31c:	08 95       	ret

0000031e <xPortStartScheduler>:
     31e:	0e 94 13 01 	call	0x226	; 0x226 <prvSetupTimerInterrupt>
     322:	a0 91 9e 04 	lds	r26, 0x049E	; 0x80049e <pxCurrentTCB>
     326:	b0 91 9f 04 	lds	r27, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     32a:	cd 91       	ld	r28, X+
     32c:	cd bf       	out	0x3d, r28	; 61
     32e:	dd 91       	ld	r29, X+
     330:	de bf       	out	0x3e, r29	; 62
     332:	ff 91       	pop	r31
     334:	ef 91       	pop	r30
     336:	df 91       	pop	r29
     338:	cf 91       	pop	r28
     33a:	bf 91       	pop	r27
     33c:	af 91       	pop	r26
     33e:	9f 91       	pop	r25
     340:	8f 91       	pop	r24
     342:	7f 91       	pop	r23
     344:	6f 91       	pop	r22
     346:	5f 91       	pop	r21
     348:	4f 91       	pop	r20
     34a:	3f 91       	pop	r19
     34c:	2f 91       	pop	r18
     34e:	1f 91       	pop	r17
     350:	0f 91       	pop	r16
     352:	ff 90       	pop	r15
     354:	ef 90       	pop	r14
     356:	df 90       	pop	r13
     358:	cf 90       	pop	r12
     35a:	bf 90       	pop	r11
     35c:	af 90       	pop	r10
     35e:	9f 90       	pop	r9
     360:	8f 90       	pop	r8
     362:	7f 90       	pop	r7
     364:	6f 90       	pop	r6
     366:	5f 90       	pop	r5
     368:	4f 90       	pop	r4
     36a:	3f 90       	pop	r3
     36c:	2f 90       	pop	r2
     36e:	1f 90       	pop	r1
     370:	0f 90       	pop	r0
     372:	0f be       	out	0x3f, r0	; 63
     374:	0f 90       	pop	r0
     376:	08 95       	ret
     378:	81 e0       	ldi	r24, 0x01	; 1
     37a:	08 95       	ret

0000037c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     37c:	0f 92       	push	r0
     37e:	0f b6       	in	r0, 0x3f	; 63
     380:	f8 94       	cli
     382:	0f 92       	push	r0
     384:	1f 92       	push	r1
     386:	11 24       	eor	r1, r1
     388:	2f 92       	push	r2
     38a:	3f 92       	push	r3
     38c:	4f 92       	push	r4
     38e:	5f 92       	push	r5
     390:	6f 92       	push	r6
     392:	7f 92       	push	r7
     394:	8f 92       	push	r8
     396:	9f 92       	push	r9
     398:	af 92       	push	r10
     39a:	bf 92       	push	r11
     39c:	cf 92       	push	r12
     39e:	df 92       	push	r13
     3a0:	ef 92       	push	r14
     3a2:	ff 92       	push	r15
     3a4:	0f 93       	push	r16
     3a6:	1f 93       	push	r17
     3a8:	2f 93       	push	r18
     3aa:	3f 93       	push	r19
     3ac:	4f 93       	push	r20
     3ae:	5f 93       	push	r21
     3b0:	6f 93       	push	r22
     3b2:	7f 93       	push	r23
     3b4:	8f 93       	push	r24
     3b6:	9f 93       	push	r25
     3b8:	af 93       	push	r26
     3ba:	bf 93       	push	r27
     3bc:	cf 93       	push	r28
     3be:	df 93       	push	r29
     3c0:	ef 93       	push	r30
     3c2:	ff 93       	push	r31
     3c4:	a0 91 9e 04 	lds	r26, 0x049E	; 0x80049e <pxCurrentTCB>
     3c8:	b0 91 9f 04 	lds	r27, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     3cc:	0d b6       	in	r0, 0x3d	; 61
     3ce:	0d 92       	st	X+, r0
     3d0:	0e b6       	in	r0, 0x3e	; 62
     3d2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     3d4:	0e 94 64 08 	call	0x10c8	; 0x10c8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     3d8:	a0 91 9e 04 	lds	r26, 0x049E	; 0x80049e <pxCurrentTCB>
     3dc:	b0 91 9f 04 	lds	r27, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     3e0:	cd 91       	ld	r28, X+
     3e2:	cd bf       	out	0x3d, r28	; 61
     3e4:	dd 91       	ld	r29, X+
     3e6:	de bf       	out	0x3e, r29	; 62
     3e8:	ff 91       	pop	r31
     3ea:	ef 91       	pop	r30
     3ec:	df 91       	pop	r29
     3ee:	cf 91       	pop	r28
     3f0:	bf 91       	pop	r27
     3f2:	af 91       	pop	r26
     3f4:	9f 91       	pop	r25
     3f6:	8f 91       	pop	r24
     3f8:	7f 91       	pop	r23
     3fa:	6f 91       	pop	r22
     3fc:	5f 91       	pop	r21
     3fe:	4f 91       	pop	r20
     400:	3f 91       	pop	r19
     402:	2f 91       	pop	r18
     404:	1f 91       	pop	r17
     406:	0f 91       	pop	r16
     408:	ff 90       	pop	r15
     40a:	ef 90       	pop	r14
     40c:	df 90       	pop	r13
     40e:	cf 90       	pop	r12
     410:	bf 90       	pop	r11
     412:	af 90       	pop	r10
     414:	9f 90       	pop	r9
     416:	8f 90       	pop	r8
     418:	7f 90       	pop	r7
     41a:	6f 90       	pop	r6
     41c:	5f 90       	pop	r5
     41e:	4f 90       	pop	r4
     420:	3f 90       	pop	r3
     422:	2f 90       	pop	r2
     424:	1f 90       	pop	r1
     426:	0f 90       	pop	r0
     428:	0f be       	out	0x3f, r0	; 63
     42a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     42c:	08 95       	ret

0000042e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     42e:	0f 92       	push	r0
     430:	0f b6       	in	r0, 0x3f	; 63
     432:	f8 94       	cli
     434:	0f 92       	push	r0
     436:	1f 92       	push	r1
     438:	11 24       	eor	r1, r1
     43a:	2f 92       	push	r2
     43c:	3f 92       	push	r3
     43e:	4f 92       	push	r4
     440:	5f 92       	push	r5
     442:	6f 92       	push	r6
     444:	7f 92       	push	r7
     446:	8f 92       	push	r8
     448:	9f 92       	push	r9
     44a:	af 92       	push	r10
     44c:	bf 92       	push	r11
     44e:	cf 92       	push	r12
     450:	df 92       	push	r13
     452:	ef 92       	push	r14
     454:	ff 92       	push	r15
     456:	0f 93       	push	r16
     458:	1f 93       	push	r17
     45a:	2f 93       	push	r18
     45c:	3f 93       	push	r19
     45e:	4f 93       	push	r20
     460:	5f 93       	push	r21
     462:	6f 93       	push	r22
     464:	7f 93       	push	r23
     466:	8f 93       	push	r24
     468:	9f 93       	push	r25
     46a:	af 93       	push	r26
     46c:	bf 93       	push	r27
     46e:	cf 93       	push	r28
     470:	df 93       	push	r29
     472:	ef 93       	push	r30
     474:	ff 93       	push	r31
     476:	a0 91 9e 04 	lds	r26, 0x049E	; 0x80049e <pxCurrentTCB>
     47a:	b0 91 9f 04 	lds	r27, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     47e:	0d b6       	in	r0, 0x3d	; 61
     480:	0d 92       	st	X+, r0
     482:	0e b6       	in	r0, 0x3e	; 62
     484:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     486:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <xTaskIncrementTick>
     48a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     48c:	0e 94 64 08 	call	0x10c8	; 0x10c8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     490:	a0 91 9e 04 	lds	r26, 0x049E	; 0x80049e <pxCurrentTCB>
     494:	b0 91 9f 04 	lds	r27, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     498:	cd 91       	ld	r28, X+
     49a:	cd bf       	out	0x3d, r28	; 61
     49c:	dd 91       	ld	r29, X+
     49e:	de bf       	out	0x3e, r29	; 62
     4a0:	ff 91       	pop	r31
     4a2:	ef 91       	pop	r30
     4a4:	df 91       	pop	r29
     4a6:	cf 91       	pop	r28
     4a8:	bf 91       	pop	r27
     4aa:	af 91       	pop	r26
     4ac:	9f 91       	pop	r25
     4ae:	8f 91       	pop	r24
     4b0:	7f 91       	pop	r23
     4b2:	6f 91       	pop	r22
     4b4:	5f 91       	pop	r21
     4b6:	4f 91       	pop	r20
     4b8:	3f 91       	pop	r19
     4ba:	2f 91       	pop	r18
     4bc:	1f 91       	pop	r17
     4be:	0f 91       	pop	r16
     4c0:	ff 90       	pop	r15
     4c2:	ef 90       	pop	r14
     4c4:	df 90       	pop	r13
     4c6:	cf 90       	pop	r12
     4c8:	bf 90       	pop	r11
     4ca:	af 90       	pop	r10
     4cc:	9f 90       	pop	r9
     4ce:	8f 90       	pop	r8
     4d0:	7f 90       	pop	r7
     4d2:	6f 90       	pop	r6
     4d4:	5f 90       	pop	r5
     4d6:	4f 90       	pop	r4
     4d8:	3f 90       	pop	r3
     4da:	2f 90       	pop	r2
     4dc:	1f 90       	pop	r1
     4de:	0f 90       	pop	r0
     4e0:	0f be       	out	0x3f, r0	; 63
     4e2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     4e4:	08 95       	ret

000004e6 <__vector_11>:
	
	
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     4e6:	0e 94 17 02 	call	0x42e	; 0x42e <vPortYieldFromTick>
		asm volatile ( "reti" );
     4ea:	18 95       	reti

000004ec <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     4ec:	0f b6       	in	r0, 0x3f	; 63
     4ee:	f8 94       	cli
     4f0:	0f 92       	push	r0
     4f2:	fc 01       	movw	r30, r24
     4f4:	82 8d       	ldd	r24, Z+26	; 0x1a
     4f6:	81 11       	cpse	r24, r1
     4f8:	02 c0       	rjmp	.+4      	; 0x4fe <prvIsQueueEmpty+0x12>
     4fa:	81 e0       	ldi	r24, 0x01	; 1
     4fc:	01 c0       	rjmp	.+2      	; 0x500 <prvIsQueueEmpty+0x14>
     4fe:	80 e0       	ldi	r24, 0x00	; 0
     500:	0f 90       	pop	r0
     502:	0f be       	out	0x3f, r0	; 63
     504:	08 95       	ret

00000506 <prvIsQueueFull>:
     506:	0f b6       	in	r0, 0x3f	; 63
     508:	f8 94       	cli
     50a:	0f 92       	push	r0
     50c:	fc 01       	movw	r30, r24
     50e:	22 8d       	ldd	r18, Z+26	; 0x1a
     510:	83 8d       	ldd	r24, Z+27	; 0x1b
     512:	28 13       	cpse	r18, r24
     514:	02 c0       	rjmp	.+4      	; 0x51a <prvIsQueueFull+0x14>
     516:	81 e0       	ldi	r24, 0x01	; 1
     518:	01 c0       	rjmp	.+2      	; 0x51c <prvIsQueueFull+0x16>
     51a:	80 e0       	ldi	r24, 0x00	; 0
     51c:	0f 90       	pop	r0
     51e:	0f be       	out	0x3f, r0	; 63
     520:	08 95       	ret

00000522 <prvCopyDataToQueue>:
     522:	0f 93       	push	r16
     524:	1f 93       	push	r17
     526:	cf 93       	push	r28
     528:	df 93       	push	r29
     52a:	ec 01       	movw	r28, r24
     52c:	04 2f       	mov	r16, r20
     52e:	1a 8d       	ldd	r17, Y+26	; 0x1a
     530:	4c 8d       	ldd	r20, Y+28	; 0x1c
     532:	44 23       	and	r20, r20
     534:	b9 f1       	breq	.+110    	; 0x5a4 <prvCopyDataToQueue+0x82>
     536:	01 11       	cpse	r16, r1
     538:	16 c0       	rjmp	.+44     	; 0x566 <prvCopyDataToQueue+0x44>
     53a:	50 e0       	ldi	r21, 0x00	; 0
     53c:	8c 81       	ldd	r24, Y+4	; 0x04
     53e:	9d 81       	ldd	r25, Y+5	; 0x05
     540:	0e 94 43 0b 	call	0x1686	; 0x1686 <memcpy>
     544:	2c 8d       	ldd	r18, Y+28	; 0x1c
     546:	8c 81       	ldd	r24, Y+4	; 0x04
     548:	9d 81       	ldd	r25, Y+5	; 0x05
     54a:	82 0f       	add	r24, r18
     54c:	91 1d       	adc	r25, r1
     54e:	9d 83       	std	Y+5, r25	; 0x05
     550:	8c 83       	std	Y+4, r24	; 0x04
     552:	2a 81       	ldd	r18, Y+2	; 0x02
     554:	3b 81       	ldd	r19, Y+3	; 0x03
     556:	82 17       	cp	r24, r18
     558:	93 07       	cpc	r25, r19
     55a:	20 f1       	brcs	.+72     	; 0x5a4 <prvCopyDataToQueue+0x82>
     55c:	88 81       	ld	r24, Y
     55e:	99 81       	ldd	r25, Y+1	; 0x01
     560:	9d 83       	std	Y+5, r25	; 0x05
     562:	8c 83       	std	Y+4, r24	; 0x04
     564:	1f c0       	rjmp	.+62     	; 0x5a4 <prvCopyDataToQueue+0x82>
     566:	50 e0       	ldi	r21, 0x00	; 0
     568:	8e 81       	ldd	r24, Y+6	; 0x06
     56a:	9f 81       	ldd	r25, Y+7	; 0x07
     56c:	0e 94 43 0b 	call	0x1686	; 0x1686 <memcpy>
     570:	8c 8d       	ldd	r24, Y+28	; 0x1c
     572:	90 e0       	ldi	r25, 0x00	; 0
     574:	91 95       	neg	r25
     576:	81 95       	neg	r24
     578:	91 09       	sbc	r25, r1
     57a:	2e 81       	ldd	r18, Y+6	; 0x06
     57c:	3f 81       	ldd	r19, Y+7	; 0x07
     57e:	28 0f       	add	r18, r24
     580:	39 1f       	adc	r19, r25
     582:	3f 83       	std	Y+7, r19	; 0x07
     584:	2e 83       	std	Y+6, r18	; 0x06
     586:	48 81       	ld	r20, Y
     588:	59 81       	ldd	r21, Y+1	; 0x01
     58a:	24 17       	cp	r18, r20
     58c:	35 07       	cpc	r19, r21
     58e:	30 f4       	brcc	.+12     	; 0x59c <prvCopyDataToQueue+0x7a>
     590:	2a 81       	ldd	r18, Y+2	; 0x02
     592:	3b 81       	ldd	r19, Y+3	; 0x03
     594:	82 0f       	add	r24, r18
     596:	93 1f       	adc	r25, r19
     598:	9f 83       	std	Y+7, r25	; 0x07
     59a:	8e 83       	std	Y+6, r24	; 0x06
     59c:	02 30       	cpi	r16, 0x02	; 2
     59e:	11 f4       	brne	.+4      	; 0x5a4 <prvCopyDataToQueue+0x82>
     5a0:	11 11       	cpse	r17, r1
     5a2:	11 50       	subi	r17, 0x01	; 1
     5a4:	1f 5f       	subi	r17, 0xFF	; 255
     5a6:	1a 8f       	std	Y+26, r17	; 0x1a
     5a8:	80 e0       	ldi	r24, 0x00	; 0
     5aa:	df 91       	pop	r29
     5ac:	cf 91       	pop	r28
     5ae:	1f 91       	pop	r17
     5b0:	0f 91       	pop	r16
     5b2:	08 95       	ret

000005b4 <prvCopyDataFromQueue>:
     5b4:	fc 01       	movw	r30, r24
     5b6:	44 8d       	ldd	r20, Z+28	; 0x1c
     5b8:	44 23       	and	r20, r20
     5ba:	a9 f0       	breq	.+42     	; 0x5e6 <prvCopyDataFromQueue+0x32>
     5bc:	50 e0       	ldi	r21, 0x00	; 0
     5be:	26 81       	ldd	r18, Z+6	; 0x06
     5c0:	37 81       	ldd	r19, Z+7	; 0x07
     5c2:	24 0f       	add	r18, r20
     5c4:	35 1f       	adc	r19, r21
     5c6:	37 83       	std	Z+7, r19	; 0x07
     5c8:	26 83       	std	Z+6, r18	; 0x06
     5ca:	82 81       	ldd	r24, Z+2	; 0x02
     5cc:	93 81       	ldd	r25, Z+3	; 0x03
     5ce:	28 17       	cp	r18, r24
     5d0:	39 07       	cpc	r19, r25
     5d2:	20 f0       	brcs	.+8      	; 0x5dc <prvCopyDataFromQueue+0x28>
     5d4:	80 81       	ld	r24, Z
     5d6:	91 81       	ldd	r25, Z+1	; 0x01
     5d8:	97 83       	std	Z+7, r25	; 0x07
     5da:	86 83       	std	Z+6, r24	; 0x06
     5dc:	cb 01       	movw	r24, r22
     5de:	66 81       	ldd	r22, Z+6	; 0x06
     5e0:	77 81       	ldd	r23, Z+7	; 0x07
     5e2:	0e 94 43 0b 	call	0x1686	; 0x1686 <memcpy>
     5e6:	08 95       	ret

000005e8 <prvUnlockQueue>:
     5e8:	1f 93       	push	r17
     5ea:	cf 93       	push	r28
     5ec:	df 93       	push	r29
     5ee:	ec 01       	movw	r28, r24
     5f0:	0f b6       	in	r0, 0x3f	; 63
     5f2:	f8 94       	cli
     5f4:	0f 92       	push	r0
     5f6:	1e 8d       	ldd	r17, Y+30	; 0x1e
     5f8:	0b c0       	rjmp	.+22     	; 0x610 <prvUnlockQueue+0x28>
     5fa:	89 89       	ldd	r24, Y+17	; 0x11
     5fc:	88 23       	and	r24, r24
     5fe:	51 f0       	breq	.+20     	; 0x614 <prvUnlockQueue+0x2c>
     600:	ce 01       	movw	r24, r28
     602:	41 96       	adiw	r24, 0x11	; 17
     604:	0e 94 ca 08 	call	0x1194	; 0x1194 <xTaskRemoveFromEventList>
     608:	81 11       	cpse	r24, r1
     60a:	0e 94 56 09 	call	0x12ac	; 0x12ac <vTaskMissedYield>
     60e:	11 50       	subi	r17, 0x01	; 1
     610:	11 16       	cp	r1, r17
     612:	9c f3       	brlt	.-26     	; 0x5fa <prvUnlockQueue+0x12>
     614:	8f ef       	ldi	r24, 0xFF	; 255
     616:	8e 8f       	std	Y+30, r24	; 0x1e
     618:	0f 90       	pop	r0
     61a:	0f be       	out	0x3f, r0	; 63
     61c:	0f b6       	in	r0, 0x3f	; 63
     61e:	f8 94       	cli
     620:	0f 92       	push	r0
     622:	1d 8d       	ldd	r17, Y+29	; 0x1d
     624:	0b c0       	rjmp	.+22     	; 0x63c <prvUnlockQueue+0x54>
     626:	88 85       	ldd	r24, Y+8	; 0x08
     628:	88 23       	and	r24, r24
     62a:	51 f0       	breq	.+20     	; 0x640 <prvUnlockQueue+0x58>
     62c:	ce 01       	movw	r24, r28
     62e:	08 96       	adiw	r24, 0x08	; 8
     630:	0e 94 ca 08 	call	0x1194	; 0x1194 <xTaskRemoveFromEventList>
     634:	81 11       	cpse	r24, r1
     636:	0e 94 56 09 	call	0x12ac	; 0x12ac <vTaskMissedYield>
     63a:	11 50       	subi	r17, 0x01	; 1
     63c:	11 16       	cp	r1, r17
     63e:	9c f3       	brlt	.-26     	; 0x626 <prvUnlockQueue+0x3e>
     640:	8f ef       	ldi	r24, 0xFF	; 255
     642:	8d 8f       	std	Y+29, r24	; 0x1d
     644:	0f 90       	pop	r0
     646:	0f be       	out	0x3f, r0	; 63
     648:	df 91       	pop	r29
     64a:	cf 91       	pop	r28
     64c:	1f 91       	pop	r17
     64e:	08 95       	ret

00000650 <xQueueGenericReset>:
     650:	cf 93       	push	r28
     652:	df 93       	push	r29
     654:	ec 01       	movw	r28, r24
     656:	0f b6       	in	r0, 0x3f	; 63
     658:	f8 94       	cli
     65a:	0f 92       	push	r0
     65c:	e8 81       	ld	r30, Y
     65e:	f9 81       	ldd	r31, Y+1	; 0x01
     660:	8b 8d       	ldd	r24, Y+27	; 0x1b
     662:	90 e0       	ldi	r25, 0x00	; 0
     664:	2c 8d       	ldd	r18, Y+28	; 0x1c
     666:	30 e0       	ldi	r19, 0x00	; 0
     668:	82 9f       	mul	r24, r18
     66a:	a0 01       	movw	r20, r0
     66c:	83 9f       	mul	r24, r19
     66e:	50 0d       	add	r21, r0
     670:	92 9f       	mul	r25, r18
     672:	50 0d       	add	r21, r0
     674:	11 24       	eor	r1, r1
     676:	4e 0f       	add	r20, r30
     678:	5f 1f       	adc	r21, r31
     67a:	5b 83       	std	Y+3, r21	; 0x03
     67c:	4a 83       	std	Y+2, r20	; 0x02
     67e:	1a 8e       	std	Y+26, r1	; 0x1a
     680:	fd 83       	std	Y+5, r31	; 0x05
     682:	ec 83       	std	Y+4, r30	; 0x04
     684:	01 97       	sbiw	r24, 0x01	; 1
     686:	28 9f       	mul	r18, r24
     688:	a0 01       	movw	r20, r0
     68a:	29 9f       	mul	r18, r25
     68c:	50 0d       	add	r21, r0
     68e:	38 9f       	mul	r19, r24
     690:	50 0d       	add	r21, r0
     692:	11 24       	eor	r1, r1
     694:	cf 01       	movw	r24, r30
     696:	84 0f       	add	r24, r20
     698:	95 1f       	adc	r25, r21
     69a:	9f 83       	std	Y+7, r25	; 0x07
     69c:	8e 83       	std	Y+6, r24	; 0x06
     69e:	8f ef       	ldi	r24, 0xFF	; 255
     6a0:	8d 8f       	std	Y+29, r24	; 0x1d
     6a2:	8e 8f       	std	Y+30, r24	; 0x1e
     6a4:	61 11       	cpse	r22, r1
     6a6:	0c c0       	rjmp	.+24     	; 0x6c0 <xQueueGenericReset+0x70>
     6a8:	88 85       	ldd	r24, Y+8	; 0x08
     6aa:	88 23       	and	r24, r24
     6ac:	89 f0       	breq	.+34     	; 0x6d0 <xQueueGenericReset+0x80>
     6ae:	ce 01       	movw	r24, r28
     6b0:	08 96       	adiw	r24, 0x08	; 8
     6b2:	0e 94 ca 08 	call	0x1194	; 0x1194 <xTaskRemoveFromEventList>
     6b6:	88 23       	and	r24, r24
     6b8:	59 f0       	breq	.+22     	; 0x6d0 <xQueueGenericReset+0x80>
     6ba:	0e 94 be 01 	call	0x37c	; 0x37c <vPortYield>
     6be:	08 c0       	rjmp	.+16     	; 0x6d0 <xQueueGenericReset+0x80>
     6c0:	ce 01       	movw	r24, r28
     6c2:	08 96       	adiw	r24, 0x08	; 8
     6c4:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
     6c8:	ce 01       	movw	r24, r28
     6ca:	41 96       	adiw	r24, 0x11	; 17
     6cc:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
     6d0:	0f 90       	pop	r0
     6d2:	0f be       	out	0x3f, r0	; 63
     6d4:	81 e0       	ldi	r24, 0x01	; 1
     6d6:	df 91       	pop	r29
     6d8:	cf 91       	pop	r28
     6da:	08 95       	ret

000006dc <prvInitialiseNewQueue>:
     6dc:	0f 93       	push	r16
     6de:	1f 93       	push	r17
     6e0:	f8 01       	movw	r30, r16
     6e2:	61 11       	cpse	r22, r1
     6e4:	03 c0       	rjmp	.+6      	; 0x6ec <prvInitialiseNewQueue+0x10>
     6e6:	11 83       	std	Z+1, r17	; 0x01
     6e8:	00 83       	st	Z, r16
     6ea:	02 c0       	rjmp	.+4      	; 0x6f0 <prvInitialiseNewQueue+0x14>
     6ec:	51 83       	std	Z+1, r21	; 0x01
     6ee:	40 83       	st	Z, r20
     6f0:	83 8f       	std	Z+27, r24	; 0x1b
     6f2:	64 8f       	std	Z+28, r22	; 0x1c
     6f4:	61 e0       	ldi	r22, 0x01	; 1
     6f6:	cf 01       	movw	r24, r30
     6f8:	0e 94 28 03 	call	0x650	; 0x650 <xQueueGenericReset>
     6fc:	1f 91       	pop	r17
     6fe:	0f 91       	pop	r16
     700:	08 95       	ret

00000702 <xQueueGenericCreate>:
     702:	df 92       	push	r13
     704:	ef 92       	push	r14
     706:	ff 92       	push	r15
     708:	0f 93       	push	r16
     70a:	1f 93       	push	r17
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	e8 2e       	mov	r14, r24
     712:	f6 2e       	mov	r15, r22
     714:	d4 2e       	mov	r13, r20
     716:	66 23       	and	r22, r22
     718:	21 f0       	breq	.+8      	; 0x722 <xQueueGenericCreate+0x20>
     71a:	86 9f       	mul	r24, r22
     71c:	c0 01       	movw	r24, r0
     71e:	11 24       	eor	r1, r1
     720:	02 c0       	rjmp	.+4      	; 0x726 <xQueueGenericCreate+0x24>
     722:	80 e0       	ldi	r24, 0x00	; 0
     724:	90 e0       	ldi	r25, 0x00	; 0
     726:	4f 96       	adiw	r24, 0x1f	; 31
     728:	0e 94 53 00 	call	0xa6	; 0xa6 <pvPortMalloc>
     72c:	ec 01       	movw	r28, r24
     72e:	00 97       	sbiw	r24, 0x00	; 0
     730:	49 f0       	breq	.+18     	; 0x744 <xQueueGenericCreate+0x42>
     732:	8c 01       	movw	r16, r24
     734:	2d 2d       	mov	r18, r13
     736:	ac 01       	movw	r20, r24
     738:	41 5e       	subi	r20, 0xE1	; 225
     73a:	5f 4f       	sbci	r21, 0xFF	; 255
     73c:	6f 2d       	mov	r22, r15
     73e:	8e 2d       	mov	r24, r14
     740:	0e 94 6e 03 	call	0x6dc	; 0x6dc <prvInitialiseNewQueue>
     744:	ce 01       	movw	r24, r28
     746:	df 91       	pop	r29
     748:	cf 91       	pop	r28
     74a:	1f 91       	pop	r17
     74c:	0f 91       	pop	r16
     74e:	ff 90       	pop	r15
     750:	ef 90       	pop	r14
     752:	df 90       	pop	r13
     754:	08 95       	ret

00000756 <xQueueGenericSend>:
     756:	cf 92       	push	r12
     758:	df 92       	push	r13
     75a:	ef 92       	push	r14
     75c:	ff 92       	push	r15
     75e:	0f 93       	push	r16
     760:	1f 93       	push	r17
     762:	cf 93       	push	r28
     764:	df 93       	push	r29
     766:	00 d0       	rcall	.+0      	; 0x768 <xQueueGenericSend+0x12>
     768:	00 d0       	rcall	.+0      	; 0x76a <xQueueGenericSend+0x14>
     76a:	1f 92       	push	r1
     76c:	cd b7       	in	r28, 0x3d	; 61
     76e:	de b7       	in	r29, 0x3e	; 62
     770:	8c 01       	movw	r16, r24
     772:	7b 01       	movw	r14, r22
     774:	5d 83       	std	Y+5, r21	; 0x05
     776:	4c 83       	std	Y+4, r20	; 0x04
     778:	c2 2e       	mov	r12, r18
     77a:	d1 2c       	mov	r13, r1
     77c:	0f b6       	in	r0, 0x3f	; 63
     77e:	f8 94       	cli
     780:	0f 92       	push	r0
     782:	f8 01       	movw	r30, r16
     784:	92 8d       	ldd	r25, Z+26	; 0x1a
     786:	83 8d       	ldd	r24, Z+27	; 0x1b
     788:	98 17       	cp	r25, r24
     78a:	18 f0       	brcs	.+6      	; 0x792 <xQueueGenericSend+0x3c>
     78c:	f2 e0       	ldi	r31, 0x02	; 2
     78e:	cf 12       	cpse	r12, r31
     790:	19 c0       	rjmp	.+50     	; 0x7c4 <xQueueGenericSend+0x6e>
     792:	4c 2d       	mov	r20, r12
     794:	b7 01       	movw	r22, r14
     796:	c8 01       	movw	r24, r16
     798:	0e 94 91 02 	call	0x522	; 0x522 <prvCopyDataToQueue>
     79c:	f8 01       	movw	r30, r16
     79e:	91 89       	ldd	r25, Z+17	; 0x11
     7a0:	99 23       	and	r25, r25
     7a2:	49 f0       	breq	.+18     	; 0x7b6 <xQueueGenericSend+0x60>
     7a4:	c8 01       	movw	r24, r16
     7a6:	41 96       	adiw	r24, 0x11	; 17
     7a8:	0e 94 ca 08 	call	0x1194	; 0x1194 <xTaskRemoveFromEventList>
     7ac:	88 23       	and	r24, r24
     7ae:	31 f0       	breq	.+12     	; 0x7bc <xQueueGenericSend+0x66>
     7b0:	0e 94 be 01 	call	0x37c	; 0x37c <vPortYield>
     7b4:	03 c0       	rjmp	.+6      	; 0x7bc <xQueueGenericSend+0x66>
     7b6:	81 11       	cpse	r24, r1
     7b8:	0e 94 be 01 	call	0x37c	; 0x37c <vPortYield>
     7bc:	0f 90       	pop	r0
     7be:	0f be       	out	0x3f, r0	; 63
     7c0:	81 e0       	ldi	r24, 0x01	; 1
     7c2:	4d c0       	rjmp	.+154    	; 0x85e <__DATA_REGION_LENGTH__+0x5e>
     7c4:	8c 81       	ldd	r24, Y+4	; 0x04
     7c6:	9d 81       	ldd	r25, Y+5	; 0x05
     7c8:	89 2b       	or	r24, r25
     7ca:	21 f4       	brne	.+8      	; 0x7d4 <xQueueGenericSend+0x7e>
     7cc:	0f 90       	pop	r0
     7ce:	0f be       	out	0x3f, r0	; 63
     7d0:	80 e0       	ldi	r24, 0x00	; 0
     7d2:	45 c0       	rjmp	.+138    	; 0x85e <__DATA_REGION_LENGTH__+0x5e>
     7d4:	d1 10       	cpse	r13, r1
     7d6:	06 c0       	rjmp	.+12     	; 0x7e4 <xQueueGenericSend+0x8e>
     7d8:	ce 01       	movw	r24, r28
     7da:	01 96       	adiw	r24, 0x01	; 1
     7dc:	0e 94 12 09 	call	0x1224	; 0x1224 <vTaskSetTimeOutState>
     7e0:	dd 24       	eor	r13, r13
     7e2:	d3 94       	inc	r13
     7e4:	0f 90       	pop	r0
     7e6:	0f be       	out	0x3f, r0	; 63
     7e8:	0e 94 e5 06 	call	0xdca	; 0xdca <vTaskSuspendAll>
     7ec:	0f b6       	in	r0, 0x3f	; 63
     7ee:	f8 94       	cli
     7f0:	0f 92       	push	r0
     7f2:	f8 01       	movw	r30, r16
     7f4:	85 8d       	ldd	r24, Z+29	; 0x1d
     7f6:	8f 3f       	cpi	r24, 0xFF	; 255
     7f8:	09 f4       	brne	.+2      	; 0x7fc <xQueueGenericSend+0xa6>
     7fa:	15 8e       	std	Z+29, r1	; 0x1d
     7fc:	f8 01       	movw	r30, r16
     7fe:	86 8d       	ldd	r24, Z+30	; 0x1e
     800:	8f 3f       	cpi	r24, 0xFF	; 255
     802:	09 f4       	brne	.+2      	; 0x806 <__DATA_REGION_LENGTH__+0x6>
     804:	16 8e       	std	Z+30, r1	; 0x1e
     806:	0f 90       	pop	r0
     808:	0f be       	out	0x3f, r0	; 63
     80a:	be 01       	movw	r22, r28
     80c:	6c 5f       	subi	r22, 0xFC	; 252
     80e:	7f 4f       	sbci	r23, 0xFF	; 255
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	0e 94 1d 09 	call	0x123a	; 0x123a <xTaskCheckForTimeOut>
     818:	81 11       	cpse	r24, r1
     81a:	1b c0       	rjmp	.+54     	; 0x852 <__DATA_REGION_LENGTH__+0x52>
     81c:	c8 01       	movw	r24, r16
     81e:	0e 94 83 02 	call	0x506	; 0x506 <prvIsQueueFull>
     822:	88 23       	and	r24, r24
     824:	81 f0       	breq	.+32     	; 0x846 <__DATA_REGION_LENGTH__+0x46>
     826:	6c 81       	ldd	r22, Y+4	; 0x04
     828:	7d 81       	ldd	r23, Y+5	; 0x05
     82a:	c8 01       	movw	r24, r16
     82c:	08 96       	adiw	r24, 0x08	; 8
     82e:	0e 94 b8 08 	call	0x1170	; 0x1170 <vTaskPlaceOnEventList>
     832:	c8 01       	movw	r24, r16
     834:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <prvUnlockQueue>
     838:	0e 94 a5 07 	call	0xf4a	; 0xf4a <xTaskResumeAll>
     83c:	81 11       	cpse	r24, r1
     83e:	9e cf       	rjmp	.-196    	; 0x77c <xQueueGenericSend+0x26>
     840:	0e 94 be 01 	call	0x37c	; 0x37c <vPortYield>
     844:	9b cf       	rjmp	.-202    	; 0x77c <xQueueGenericSend+0x26>
     846:	c8 01       	movw	r24, r16
     848:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <prvUnlockQueue>
     84c:	0e 94 a5 07 	call	0xf4a	; 0xf4a <xTaskResumeAll>
     850:	95 cf       	rjmp	.-214    	; 0x77c <xQueueGenericSend+0x26>
     852:	c8 01       	movw	r24, r16
     854:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <prvUnlockQueue>
     858:	0e 94 a5 07 	call	0xf4a	; 0xf4a <xTaskResumeAll>
     85c:	80 e0       	ldi	r24, 0x00	; 0
     85e:	0f 90       	pop	r0
     860:	0f 90       	pop	r0
     862:	0f 90       	pop	r0
     864:	0f 90       	pop	r0
     866:	0f 90       	pop	r0
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	1f 91       	pop	r17
     86e:	0f 91       	pop	r16
     870:	ff 90       	pop	r15
     872:	ef 90       	pop	r14
     874:	df 90       	pop	r13
     876:	cf 90       	pop	r12
     878:	08 95       	ret

0000087a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     87a:	8f 92       	push	r8
     87c:	9f 92       	push	r9
     87e:	bf 92       	push	r11
     880:	cf 92       	push	r12
     882:	df 92       	push	r13
     884:	ef 92       	push	r14
     886:	ff 92       	push	r15
     888:	0f 93       	push	r16
     88a:	1f 93       	push	r17
     88c:	cf 93       	push	r28
     88e:	df 93       	push	r29
     890:	00 d0       	rcall	.+0      	; 0x892 <xQueueGenericReceive+0x18>
     892:	00 d0       	rcall	.+0      	; 0x894 <xQueueGenericReceive+0x1a>
     894:	1f 92       	push	r1
     896:	cd b7       	in	r28, 0x3d	; 61
     898:	de b7       	in	r29, 0x3e	; 62
     89a:	8c 01       	movw	r16, r24
     89c:	6b 01       	movw	r12, r22
     89e:	5d 83       	std	Y+5, r21	; 0x05
     8a0:	4c 83       	std	Y+4, r20	; 0x04
     8a2:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
     8a4:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     8a6:	0f b6       	in	r0, 0x3f	; 63
     8a8:	f8 94       	cli
     8aa:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     8ac:	f8 01       	movw	r30, r16
     8ae:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     8b0:	ff 20       	and	r15, r15
     8b2:	41 f1       	breq	.+80     	; 0x904 <__stack+0x5>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     8b4:	86 80       	ldd	r8, Z+6	; 0x06
     8b6:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     8b8:	b6 01       	movw	r22, r12
     8ba:	c8 01       	movw	r24, r16
     8bc:	0e 94 da 02 	call	0x5b4	; 0x5b4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     8c0:	b1 10       	cpse	r11, r1
     8c2:	0f c0       	rjmp	.+30     	; 0x8e2 <xQueueGenericReceive+0x68>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     8c4:	fa 94       	dec	r15
     8c6:	f8 01       	movw	r30, r16
     8c8:	f2 8e       	std	Z+26, r15	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     8ca:	80 85       	ldd	r24, Z+8	; 0x08
     8cc:	88 23       	and	r24, r24
     8ce:	b1 f0       	breq	.+44     	; 0x8fc <xQueueGenericReceive+0x82>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     8d0:	c8 01       	movw	r24, r16
     8d2:	08 96       	adiw	r24, 0x08	; 8
     8d4:	0e 94 ca 08 	call	0x1194	; 0x1194 <xTaskRemoveFromEventList>
     8d8:	88 23       	and	r24, r24
     8da:	81 f0       	breq	.+32     	; 0x8fc <xQueueGenericReceive+0x82>
						{
							queueYIELD_IF_USING_PREEMPTION();
     8dc:	0e 94 be 01 	call	0x37c	; 0x37c <vPortYield>
     8e0:	0d c0       	rjmp	.+26     	; 0x8fc <xQueueGenericReceive+0x82>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     8e2:	f8 01       	movw	r30, r16
     8e4:	97 82       	std	Z+7, r9	; 0x07
     8e6:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     8e8:	81 89       	ldd	r24, Z+17	; 0x11
     8ea:	88 23       	and	r24, r24
     8ec:	39 f0       	breq	.+14     	; 0x8fc <xQueueGenericReceive+0x82>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     8ee:	c8 01       	movw	r24, r16
     8f0:	41 96       	adiw	r24, 0x11	; 17
     8f2:	0e 94 ca 08 	call	0x1194	; 0x1194 <xTaskRemoveFromEventList>
     8f6:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     8f8:	0e 94 be 01 	call	0x37c	; 0x37c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     8fc:	0f 90       	pop	r0
     8fe:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	53 c0       	rjmp	.+166    	; 0x9aa <__stack+0xab>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     904:	8c 81       	ldd	r24, Y+4	; 0x04
     906:	9d 81       	ldd	r25, Y+5	; 0x05
     908:	89 2b       	or	r24, r25
     90a:	21 f4       	brne	.+8      	; 0x914 <__stack+0x15>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     90c:	0f 90       	pop	r0
     90e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     910:	80 e0       	ldi	r24, 0x00	; 0
     912:	4b c0       	rjmp	.+150    	; 0x9aa <__stack+0xab>
				}
				else if( xEntryTimeSet == pdFALSE )
     914:	e1 10       	cpse	r14, r1
     916:	06 c0       	rjmp	.+12     	; 0x924 <__stack+0x25>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     918:	ce 01       	movw	r24, r28
     91a:	01 96       	adiw	r24, 0x01	; 1
     91c:	0e 94 12 09 	call	0x1224	; 0x1224 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     920:	ee 24       	eor	r14, r14
     922:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     924:	0f 90       	pop	r0
     926:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     928:	0e 94 e5 06 	call	0xdca	; 0xdca <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     92c:	0f b6       	in	r0, 0x3f	; 63
     92e:	f8 94       	cli
     930:	0f 92       	push	r0
     932:	f8 01       	movw	r30, r16
     934:	85 8d       	ldd	r24, Z+29	; 0x1d
     936:	8f 3f       	cpi	r24, 0xFF	; 255
     938:	09 f4       	brne	.+2      	; 0x93c <__stack+0x3d>
     93a:	15 8e       	std	Z+29, r1	; 0x1d
     93c:	f8 01       	movw	r30, r16
     93e:	86 8d       	ldd	r24, Z+30	; 0x1e
     940:	8f 3f       	cpi	r24, 0xFF	; 255
     942:	09 f4       	brne	.+2      	; 0x946 <__stack+0x47>
     944:	16 8e       	std	Z+30, r1	; 0x1e
     946:	0f 90       	pop	r0
     948:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     94a:	be 01       	movw	r22, r28
     94c:	6c 5f       	subi	r22, 0xFC	; 252
     94e:	7f 4f       	sbci	r23, 0xFF	; 255
     950:	ce 01       	movw	r24, r28
     952:	01 96       	adiw	r24, 0x01	; 1
     954:	0e 94 1d 09 	call	0x123a	; 0x123a <xTaskCheckForTimeOut>
     958:	81 11       	cpse	r24, r1
     95a:	1b c0       	rjmp	.+54     	; 0x992 <__stack+0x93>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     95c:	c8 01       	movw	r24, r16
     95e:	0e 94 76 02 	call	0x4ec	; 0x4ec <prvIsQueueEmpty>
     962:	88 23       	and	r24, r24
     964:	81 f0       	breq	.+32     	; 0x986 <__stack+0x87>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     966:	6c 81       	ldd	r22, Y+4	; 0x04
     968:	7d 81       	ldd	r23, Y+5	; 0x05
     96a:	c8 01       	movw	r24, r16
     96c:	41 96       	adiw	r24, 0x11	; 17
     96e:	0e 94 b8 08 	call	0x1170	; 0x1170 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     972:	c8 01       	movw	r24, r16
     974:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     978:	0e 94 a5 07 	call	0xf4a	; 0xf4a <xTaskResumeAll>
     97c:	81 11       	cpse	r24, r1
     97e:	93 cf       	rjmp	.-218    	; 0x8a6 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
     980:	0e 94 be 01 	call	0x37c	; 0x37c <vPortYield>
     984:	90 cf       	rjmp	.-224    	; 0x8a6 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     986:	c8 01       	movw	r24, r16
     988:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     98c:	0e 94 a5 07 	call	0xf4a	; 0xf4a <xTaskResumeAll>
     990:	8a cf       	rjmp	.-236    	; 0x8a6 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     992:	c8 01       	movw	r24, r16
     994:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     998:	0e 94 a5 07 	call	0xf4a	; 0xf4a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     99c:	c8 01       	movw	r24, r16
     99e:	0e 94 76 02 	call	0x4ec	; 0x4ec <prvIsQueueEmpty>
     9a2:	88 23       	and	r24, r24
     9a4:	09 f4       	brne	.+2      	; 0x9a8 <__stack+0xa9>
     9a6:	7f cf       	rjmp	.-258    	; 0x8a6 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     9a8:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     9aa:	0f 90       	pop	r0
     9ac:	0f 90       	pop	r0
     9ae:	0f 90       	pop	r0
     9b0:	0f 90       	pop	r0
     9b2:	0f 90       	pop	r0
     9b4:	df 91       	pop	r29
     9b6:	cf 91       	pop	r28
     9b8:	1f 91       	pop	r17
     9ba:	0f 91       	pop	r16
     9bc:	ff 90       	pop	r15
     9be:	ef 90       	pop	r14
     9c0:	df 90       	pop	r13
     9c2:	cf 90       	pop	r12
     9c4:	bf 90       	pop	r11
     9c6:	9f 90       	pop	r9
     9c8:	8f 90       	pop	r8
     9ca:	08 95       	ret

000009cc <prvResetNextTaskUnblockTime>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     9cc:	e0 91 66 04 	lds	r30, 0x0466	; 0x800466 <pxDelayedTaskList>
     9d0:	f0 91 67 04 	lds	r31, 0x0467	; 0x800467 <pxDelayedTaskList+0x1>
     9d4:	80 81       	ld	r24, Z
     9d6:	81 11       	cpse	r24, r1
     9d8:	07 c0       	rjmp	.+14     	; 0x9e8 <prvResetNextTaskUnblockTime+0x1c>
     9da:	8f ef       	ldi	r24, 0xFF	; 255
     9dc:	9f ef       	ldi	r25, 0xFF	; 255
     9de:	90 93 3e 04 	sts	0x043E, r25	; 0x80043e <xNextTaskUnblockTime+0x1>
     9e2:	80 93 3d 04 	sts	0x043D, r24	; 0x80043d <xNextTaskUnblockTime>
     9e6:	08 95       	ret
     9e8:	e0 91 66 04 	lds	r30, 0x0466	; 0x800466 <pxDelayedTaskList>
     9ec:	f0 91 67 04 	lds	r31, 0x0467	; 0x800467 <pxDelayedTaskList+0x1>
     9f0:	05 80       	ldd	r0, Z+5	; 0x05
     9f2:	f6 81       	ldd	r31, Z+6	; 0x06
     9f4:	e0 2d       	mov	r30, r0
     9f6:	06 80       	ldd	r0, Z+6	; 0x06
     9f8:	f7 81       	ldd	r31, Z+7	; 0x07
     9fa:	e0 2d       	mov	r30, r0
     9fc:	82 81       	ldd	r24, Z+2	; 0x02
     9fe:	93 81       	ldd	r25, Z+3	; 0x03
     a00:	90 93 3e 04 	sts	0x043E, r25	; 0x80043e <xNextTaskUnblockTime+0x1>
     a04:	80 93 3d 04 	sts	0x043D, r24	; 0x80043d <xNextTaskUnblockTime>
     a08:	08 95       	ret

00000a0a <prvDeleteTCB>:
     a0a:	cf 93       	push	r28
     a0c:	df 93       	push	r29
     a0e:	ec 01       	movw	r28, r24
     a10:	8f 89       	ldd	r24, Y+23	; 0x17
     a12:	98 8d       	ldd	r25, Y+24	; 0x18
     a14:	0e 94 88 00 	call	0x110	; 0x110 <vPortFree>
     a18:	ce 01       	movw	r24, r28
     a1a:	0e 94 88 00 	call	0x110	; 0x110 <vPortFree>
     a1e:	df 91       	pop	r29
     a20:	cf 91       	pop	r28
     a22:	08 95       	ret

00000a24 <prvInitialiseNewTask>:
     a24:	6f 92       	push	r6
     a26:	7f 92       	push	r7
     a28:	8f 92       	push	r8
     a2a:	9f 92       	push	r9
     a2c:	af 92       	push	r10
     a2e:	bf 92       	push	r11
     a30:	cf 92       	push	r12
     a32:	df 92       	push	r13
     a34:	ef 92       	push	r14
     a36:	0f 93       	push	r16
     a38:	1f 93       	push	r17
     a3a:	cf 93       	push	r28
     a3c:	df 93       	push	r29
     a3e:	cd b7       	in	r28, 0x3d	; 61
     a40:	de b7       	in	r29, 0x3e	; 62
     a42:	4c 01       	movw	r8, r24
     a44:	f5 01       	movw	r30, r10
     a46:	87 89       	ldd	r24, Z+23	; 0x17
     a48:	90 8d       	ldd	r25, Z+24	; 0x18
     a4a:	21 50       	subi	r18, 0x01	; 1
     a4c:	31 09       	sbc	r19, r1
     a4e:	3c 01       	movw	r6, r24
     a50:	62 0e       	add	r6, r18
     a52:	73 1e       	adc	r7, r19
     a54:	20 e0       	ldi	r18, 0x00	; 0
     a56:	0f c0       	rjmp	.+30     	; 0xa76 <prvInitialiseNewTask+0x52>
     a58:	82 2f       	mov	r24, r18
     a5a:	90 e0       	ldi	r25, 0x00	; 0
     a5c:	fb 01       	movw	r30, r22
     a5e:	e8 0f       	add	r30, r24
     a60:	f9 1f       	adc	r31, r25
     a62:	30 81       	ld	r19, Z
     a64:	d5 01       	movw	r26, r10
     a66:	a8 0f       	add	r26, r24
     a68:	b9 1f       	adc	r27, r25
     a6a:	59 96       	adiw	r26, 0x19	; 25
     a6c:	3c 93       	st	X, r19
     a6e:	80 81       	ld	r24, Z
     a70:	88 23       	and	r24, r24
     a72:	19 f0       	breq	.+6      	; 0xa7a <prvInitialiseNewTask+0x56>
     a74:	2f 5f       	subi	r18, 0xFF	; 255
     a76:	28 30       	cpi	r18, 0x08	; 8
     a78:	78 f3       	brcs	.-34     	; 0xa58 <prvInitialiseNewTask+0x34>
     a7a:	f5 01       	movw	r30, r10
     a7c:	10 a2       	std	Z+32, r1	; 0x20
     a7e:	f3 e0       	ldi	r31, 0x03	; 3
     a80:	fe 15       	cp	r31, r14
     a82:	20 f4       	brcc	.+8      	; 0xa8c <prvInitialiseNewTask+0x68>
     a84:	0f 2e       	mov	r0, r31
     a86:	f3 e0       	ldi	r31, 0x03	; 3
     a88:	ef 2e       	mov	r14, r31
     a8a:	f0 2d       	mov	r31, r0
     a8c:	f5 01       	movw	r30, r10
     a8e:	e6 8a       	std	Z+22, r14	; 0x16
     a90:	c5 01       	movw	r24, r10
     a92:	02 96       	adiw	r24, 0x02	; 2
     a94:	0e 94 97 00 	call	0x12e	; 0x12e <vListInitialiseItem>
     a98:	c5 01       	movw	r24, r10
     a9a:	0c 96       	adiw	r24, 0x0c	; 12
     a9c:	0e 94 97 00 	call	0x12e	; 0x12e <vListInitialiseItem>
     aa0:	f5 01       	movw	r30, r10
     aa2:	b1 86       	std	Z+9, r11	; 0x09
     aa4:	a0 86       	std	Z+8, r10	; 0x08
     aa6:	84 e0       	ldi	r24, 0x04	; 4
     aa8:	90 e0       	ldi	r25, 0x00	; 0
     aaa:	8e 19       	sub	r24, r14
     aac:	91 09       	sbc	r25, r1
     aae:	95 87       	std	Z+13, r25	; 0x0d
     ab0:	84 87       	std	Z+12, r24	; 0x0c
     ab2:	b3 8a       	std	Z+19, r11	; 0x13
     ab4:	a2 8a       	std	Z+18, r10	; 0x12
     ab6:	11 a2       	std	Z+33, r1	; 0x21
     ab8:	12 a2       	std	Z+34, r1	; 0x22
     aba:	13 a2       	std	Z+35, r1	; 0x23
     abc:	14 a2       	std	Z+36, r1	; 0x24
     abe:	15 a2       	std	Z+37, r1	; 0x25
     ac0:	a8 01       	movw	r20, r16
     ac2:	b4 01       	movw	r22, r8
     ac4:	c3 01       	movw	r24, r6
     ac6:	0e 94 23 01 	call	0x246	; 0x246 <pxPortInitialiseStack>
     aca:	f5 01       	movw	r30, r10
     acc:	91 83       	std	Z+1, r25	; 0x01
     ace:	80 83       	st	Z, r24
     ad0:	c1 14       	cp	r12, r1
     ad2:	d1 04       	cpc	r13, r1
     ad4:	19 f0       	breq	.+6      	; 0xadc <prvInitialiseNewTask+0xb8>
     ad6:	f6 01       	movw	r30, r12
     ad8:	b1 82       	std	Z+1, r11	; 0x01
     ada:	a0 82       	st	Z, r10
     adc:	df 91       	pop	r29
     ade:	cf 91       	pop	r28
     ae0:	1f 91       	pop	r17
     ae2:	0f 91       	pop	r16
     ae4:	ef 90       	pop	r14
     ae6:	df 90       	pop	r13
     ae8:	cf 90       	pop	r12
     aea:	bf 90       	pop	r11
     aec:	af 90       	pop	r10
     aee:	9f 90       	pop	r9
     af0:	8f 90       	pop	r8
     af2:	7f 90       	pop	r7
     af4:	6f 90       	pop	r6
     af6:	08 95       	ret

00000af8 <prvInitialiseTaskLists>:
     af8:	cf 93       	push	r28
     afa:	c0 e0       	ldi	r28, 0x00	; 0
     afc:	10 c0       	rjmp	.+32     	; 0xb1e <prvInitialiseTaskLists+0x26>
     afe:	8c 2f       	mov	r24, r28
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	9c 01       	movw	r18, r24
     b04:	22 0f       	add	r18, r18
     b06:	33 1f       	adc	r19, r19
     b08:	22 0f       	add	r18, r18
     b0a:	33 1f       	adc	r19, r19
     b0c:	22 0f       	add	r18, r18
     b0e:	33 1f       	adc	r19, r19
     b10:	82 0f       	add	r24, r18
     b12:	93 1f       	adc	r25, r19
     b14:	86 58       	subi	r24, 0x86	; 134
     b16:	9b 4f       	sbci	r25, 0xFB	; 251
     b18:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
     b1c:	cf 5f       	subi	r28, 0xFF	; 255
     b1e:	c4 30       	cpi	r28, 0x04	; 4
     b20:	70 f3       	brcs	.-36     	; 0xafe <prvInitialiseTaskLists+0x6>
     b22:	81 e7       	ldi	r24, 0x71	; 113
     b24:	94 e0       	ldi	r25, 0x04	; 4
     b26:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
     b2a:	88 e6       	ldi	r24, 0x68	; 104
     b2c:	94 e0       	ldi	r25, 0x04	; 4
     b2e:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
     b32:	8b e5       	ldi	r24, 0x5B	; 91
     b34:	94 e0       	ldi	r25, 0x04	; 4
     b36:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
     b3a:	82 e5       	ldi	r24, 0x52	; 82
     b3c:	94 e0       	ldi	r25, 0x04	; 4
     b3e:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
     b42:	88 e4       	ldi	r24, 0x48	; 72
     b44:	94 e0       	ldi	r25, 0x04	; 4
     b46:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
     b4a:	81 e7       	ldi	r24, 0x71	; 113
     b4c:	94 e0       	ldi	r25, 0x04	; 4
     b4e:	90 93 67 04 	sts	0x0467, r25	; 0x800467 <pxDelayedTaskList+0x1>
     b52:	80 93 66 04 	sts	0x0466, r24	; 0x800466 <pxDelayedTaskList>
     b56:	88 e6       	ldi	r24, 0x68	; 104
     b58:	94 e0       	ldi	r25, 0x04	; 4
     b5a:	90 93 65 04 	sts	0x0465, r25	; 0x800465 <pxOverflowDelayedTaskList+0x1>
     b5e:	80 93 64 04 	sts	0x0464, r24	; 0x800464 <pxOverflowDelayedTaskList>
     b62:	cf 91       	pop	r28
     b64:	08 95       	ret

00000b66 <prvAddNewTaskToReadyList>:
     b66:	cf 93       	push	r28
     b68:	df 93       	push	r29
     b6a:	ec 01       	movw	r28, r24
     b6c:	0f b6       	in	r0, 0x3f	; 63
     b6e:	f8 94       	cli
     b70:	0f 92       	push	r0
     b72:	80 91 47 04 	lds	r24, 0x0447	; 0x800447 <uxCurrentNumberOfTasks>
     b76:	8f 5f       	subi	r24, 0xFF	; 255
     b78:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <uxCurrentNumberOfTasks>
     b7c:	80 91 9e 04 	lds	r24, 0x049E	; 0x80049e <pxCurrentTCB>
     b80:	90 91 9f 04 	lds	r25, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     b84:	89 2b       	or	r24, r25
     b86:	59 f4       	brne	.+22     	; 0xb9e <prvAddNewTaskToReadyList+0x38>
     b88:	d0 93 9f 04 	sts	0x049F, r29	; 0x80049f <pxCurrentTCB+0x1>
     b8c:	c0 93 9e 04 	sts	0x049E, r28	; 0x80049e <pxCurrentTCB>
     b90:	80 91 47 04 	lds	r24, 0x0447	; 0x800447 <uxCurrentNumberOfTasks>
     b94:	81 30       	cpi	r24, 0x01	; 1
     b96:	99 f4       	brne	.+38     	; 0xbbe <prvAddNewTaskToReadyList+0x58>
     b98:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <prvInitialiseTaskLists>
     b9c:	10 c0       	rjmp	.+32     	; 0xbbe <prvAddNewTaskToReadyList+0x58>
     b9e:	80 91 43 04 	lds	r24, 0x0443	; 0x800443 <xSchedulerRunning>
     ba2:	81 11       	cpse	r24, r1
     ba4:	0c c0       	rjmp	.+24     	; 0xbbe <prvAddNewTaskToReadyList+0x58>
     ba6:	e0 91 9e 04 	lds	r30, 0x049E	; 0x80049e <pxCurrentTCB>
     baa:	f0 91 9f 04 	lds	r31, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     bae:	96 89       	ldd	r25, Z+22	; 0x16
     bb0:	8e 89       	ldd	r24, Y+22	; 0x16
     bb2:	89 17       	cp	r24, r25
     bb4:	20 f0       	brcs	.+8      	; 0xbbe <prvAddNewTaskToReadyList+0x58>
     bb6:	d0 93 9f 04 	sts	0x049F, r29	; 0x80049f <pxCurrentTCB+0x1>
     bba:	c0 93 9e 04 	sts	0x049E, r28	; 0x80049e <pxCurrentTCB>
     bbe:	80 91 3f 04 	lds	r24, 0x043F	; 0x80043f <uxTaskNumber>
     bc2:	8f 5f       	subi	r24, 0xFF	; 255
     bc4:	80 93 3f 04 	sts	0x043F, r24	; 0x80043f <uxTaskNumber>
     bc8:	8e 89       	ldd	r24, Y+22	; 0x16
     bca:	90 91 44 04 	lds	r25, 0x0444	; 0x800444 <uxTopReadyPriority>
     bce:	98 17       	cp	r25, r24
     bd0:	10 f4       	brcc	.+4      	; 0xbd6 <prvAddNewTaskToReadyList+0x70>
     bd2:	80 93 44 04 	sts	0x0444, r24	; 0x800444 <uxTopReadyPriority>
     bd6:	90 e0       	ldi	r25, 0x00	; 0
     bd8:	9c 01       	movw	r18, r24
     bda:	22 0f       	add	r18, r18
     bdc:	33 1f       	adc	r19, r19
     bde:	22 0f       	add	r18, r18
     be0:	33 1f       	adc	r19, r19
     be2:	22 0f       	add	r18, r18
     be4:	33 1f       	adc	r19, r19
     be6:	82 0f       	add	r24, r18
     be8:	93 1f       	adc	r25, r19
     bea:	be 01       	movw	r22, r28
     bec:	6e 5f       	subi	r22, 0xFE	; 254
     bee:	7f 4f       	sbci	r23, 0xFF	; 255
     bf0:	86 58       	subi	r24, 0x86	; 134
     bf2:	9b 4f       	sbci	r25, 0xFB	; 251
     bf4:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
     bf8:	0f 90       	pop	r0
     bfa:	0f be       	out	0x3f, r0	; 63
     bfc:	80 91 43 04 	lds	r24, 0x0443	; 0x800443 <xSchedulerRunning>
     c00:	88 23       	and	r24, r24
     c02:	51 f0       	breq	.+20     	; 0xc18 <prvAddNewTaskToReadyList+0xb2>
     c04:	e0 91 9e 04 	lds	r30, 0x049E	; 0x80049e <pxCurrentTCB>
     c08:	f0 91 9f 04 	lds	r31, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     c0c:	96 89       	ldd	r25, Z+22	; 0x16
     c0e:	8e 89       	ldd	r24, Y+22	; 0x16
     c10:	98 17       	cp	r25, r24
     c12:	10 f4       	brcc	.+4      	; 0xc18 <prvAddNewTaskToReadyList+0xb2>
     c14:	0e 94 be 01 	call	0x37c	; 0x37c <vPortYield>
     c18:	df 91       	pop	r29
     c1a:	cf 91       	pop	r28
     c1c:	08 95       	ret

00000c1e <prvAddCurrentTaskToDelayedList>:
     c1e:	ff 92       	push	r15
     c20:	0f 93       	push	r16
     c22:	1f 93       	push	r17
     c24:	cf 93       	push	r28
     c26:	df 93       	push	r29
     c28:	ec 01       	movw	r28, r24
     c2a:	f6 2e       	mov	r15, r22
     c2c:	00 91 45 04 	lds	r16, 0x0445	; 0x800445 <xTickCount>
     c30:	10 91 46 04 	lds	r17, 0x0446	; 0x800446 <xTickCount+0x1>
     c34:	80 91 9e 04 	lds	r24, 0x049E	; 0x80049e <pxCurrentTCB>
     c38:	90 91 9f 04 	lds	r25, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     c3c:	02 96       	adiw	r24, 0x02	; 2
     c3e:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
     c42:	cf 3f       	cpi	r28, 0xFF	; 255
     c44:	8f ef       	ldi	r24, 0xFF	; 255
     c46:	d8 07       	cpc	r29, r24
     c48:	69 f4       	brne	.+26     	; 0xc64 <prvAddCurrentTaskToDelayedList+0x46>
     c4a:	ff 20       	and	r15, r15
     c4c:	59 f0       	breq	.+22     	; 0xc64 <prvAddCurrentTaskToDelayedList+0x46>
     c4e:	60 91 9e 04 	lds	r22, 0x049E	; 0x80049e <pxCurrentTCB>
     c52:	70 91 9f 04 	lds	r23, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     c56:	6e 5f       	subi	r22, 0xFE	; 254
     c58:	7f 4f       	sbci	r23, 0xFF	; 255
     c5a:	88 e4       	ldi	r24, 0x48	; 72
     c5c:	94 e0       	ldi	r25, 0x04	; 4
     c5e:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
     c62:	2f c0       	rjmp	.+94     	; 0xcc2 <prvAddCurrentTaskToDelayedList+0xa4>
     c64:	c0 0f       	add	r28, r16
     c66:	d1 1f       	adc	r29, r17
     c68:	e0 91 9e 04 	lds	r30, 0x049E	; 0x80049e <pxCurrentTCB>
     c6c:	f0 91 9f 04 	lds	r31, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     c70:	d3 83       	std	Z+3, r29	; 0x03
     c72:	c2 83       	std	Z+2, r28	; 0x02
     c74:	c0 17       	cp	r28, r16
     c76:	d1 07       	cpc	r29, r17
     c78:	68 f4       	brcc	.+26     	; 0xc94 <prvAddCurrentTaskToDelayedList+0x76>
     c7a:	60 91 9e 04 	lds	r22, 0x049E	; 0x80049e <pxCurrentTCB>
     c7e:	70 91 9f 04 	lds	r23, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     c82:	80 91 64 04 	lds	r24, 0x0464	; 0x800464 <pxOverflowDelayedTaskList>
     c86:	90 91 65 04 	lds	r25, 0x0465	; 0x800465 <pxOverflowDelayedTaskList+0x1>
     c8a:	6e 5f       	subi	r22, 0xFE	; 254
     c8c:	7f 4f       	sbci	r23, 0xFF	; 255
     c8e:	0e 94 bc 00 	call	0x178	; 0x178 <vListInsert>
     c92:	17 c0       	rjmp	.+46     	; 0xcc2 <prvAddCurrentTaskToDelayedList+0xa4>
     c94:	60 91 9e 04 	lds	r22, 0x049E	; 0x80049e <pxCurrentTCB>
     c98:	70 91 9f 04 	lds	r23, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     c9c:	80 91 66 04 	lds	r24, 0x0466	; 0x800466 <pxDelayedTaskList>
     ca0:	90 91 67 04 	lds	r25, 0x0467	; 0x800467 <pxDelayedTaskList+0x1>
     ca4:	6e 5f       	subi	r22, 0xFE	; 254
     ca6:	7f 4f       	sbci	r23, 0xFF	; 255
     ca8:	0e 94 bc 00 	call	0x178	; 0x178 <vListInsert>
     cac:	80 91 3d 04 	lds	r24, 0x043D	; 0x80043d <xNextTaskUnblockTime>
     cb0:	90 91 3e 04 	lds	r25, 0x043E	; 0x80043e <xNextTaskUnblockTime+0x1>
     cb4:	c8 17       	cp	r28, r24
     cb6:	d9 07       	cpc	r29, r25
     cb8:	20 f4       	brcc	.+8      	; 0xcc2 <prvAddCurrentTaskToDelayedList+0xa4>
     cba:	d0 93 3e 04 	sts	0x043E, r29	; 0x80043e <xNextTaskUnblockTime+0x1>
     cbe:	c0 93 3d 04 	sts	0x043D, r28	; 0x80043d <xNextTaskUnblockTime>
     cc2:	df 91       	pop	r29
     cc4:	cf 91       	pop	r28
     cc6:	1f 91       	pop	r17
     cc8:	0f 91       	pop	r16
     cca:	ff 90       	pop	r15
     ccc:	08 95       	ret

00000cce <xTaskCreate>:
     cce:	2f 92       	push	r2
     cd0:	3f 92       	push	r3
     cd2:	4f 92       	push	r4
     cd4:	5f 92       	push	r5
     cd6:	6f 92       	push	r6
     cd8:	7f 92       	push	r7
     cda:	8f 92       	push	r8
     cdc:	9f 92       	push	r9
     cde:	af 92       	push	r10
     ce0:	bf 92       	push	r11
     ce2:	cf 92       	push	r12
     ce4:	df 92       	push	r13
     ce6:	ef 92       	push	r14
     ce8:	ff 92       	push	r15
     cea:	0f 93       	push	r16
     cec:	1f 93       	push	r17
     cee:	cf 93       	push	r28
     cf0:	df 93       	push	r29
     cf2:	3c 01       	movw	r6, r24
     cf4:	1b 01       	movw	r2, r22
     cf6:	5a 01       	movw	r10, r20
     cf8:	29 01       	movw	r4, r18
     cfa:	ca 01       	movw	r24, r20
     cfc:	0e 94 53 00 	call	0xa6	; 0xa6 <pvPortMalloc>
     d00:	6c 01       	movw	r12, r24
     d02:	89 2b       	or	r24, r25
     d04:	71 f0       	breq	.+28     	; 0xd22 <xTaskCreate+0x54>
     d06:	86 e2       	ldi	r24, 0x26	; 38
     d08:	90 e0       	ldi	r25, 0x00	; 0
     d0a:	0e 94 53 00 	call	0xa6	; 0xa6 <pvPortMalloc>
     d0e:	ec 01       	movw	r28, r24
     d10:	89 2b       	or	r24, r25
     d12:	19 f0       	breq	.+6      	; 0xd1a <xTaskCreate+0x4c>
     d14:	d8 8e       	std	Y+24, r13	; 0x18
     d16:	cf 8a       	std	Y+23, r12	; 0x17
     d18:	06 c0       	rjmp	.+12     	; 0xd26 <xTaskCreate+0x58>
     d1a:	c6 01       	movw	r24, r12
     d1c:	0e 94 88 00 	call	0x110	; 0x110 <vPortFree>
     d20:	02 c0       	rjmp	.+4      	; 0xd26 <xTaskCreate+0x58>
     d22:	c0 e0       	ldi	r28, 0x00	; 0
     d24:	d0 e0       	ldi	r29, 0x00	; 0
     d26:	20 97       	sbiw	r28, 0x00	; 0
     d28:	91 f0       	breq	.+36     	; 0xd4e <xTaskCreate+0x80>
     d2a:	95 01       	movw	r18, r10
     d2c:	40 e0       	ldi	r20, 0x00	; 0
     d2e:	50 e0       	ldi	r21, 0x00	; 0
     d30:	81 2c       	mov	r8, r1
     d32:	91 2c       	mov	r9, r1
     d34:	5e 01       	movw	r10, r28
     d36:	67 01       	movw	r12, r14
     d38:	e0 2e       	mov	r14, r16
     d3a:	82 01       	movw	r16, r4
     d3c:	b1 01       	movw	r22, r2
     d3e:	c3 01       	movw	r24, r6
     d40:	0e 94 12 05 	call	0xa24	; 0xa24 <prvInitialiseNewTask>
     d44:	ce 01       	movw	r24, r28
     d46:	0e 94 b3 05 	call	0xb66	; 0xb66 <prvAddNewTaskToReadyList>
     d4a:	81 e0       	ldi	r24, 0x01	; 1
     d4c:	01 c0       	rjmp	.+2      	; 0xd50 <xTaskCreate+0x82>
     d4e:	8f ef       	ldi	r24, 0xFF	; 255
     d50:	df 91       	pop	r29
     d52:	cf 91       	pop	r28
     d54:	1f 91       	pop	r17
     d56:	0f 91       	pop	r16
     d58:	ff 90       	pop	r15
     d5a:	ef 90       	pop	r14
     d5c:	df 90       	pop	r13
     d5e:	cf 90       	pop	r12
     d60:	bf 90       	pop	r11
     d62:	af 90       	pop	r10
     d64:	9f 90       	pop	r9
     d66:	8f 90       	pop	r8
     d68:	7f 90       	pop	r7
     d6a:	6f 90       	pop	r6
     d6c:	5f 90       	pop	r5
     d6e:	4f 90       	pop	r4
     d70:	3f 90       	pop	r3
     d72:	2f 90       	pop	r2
     d74:	08 95       	ret

00000d76 <vTaskStartScheduler>:
     d76:	ef 92       	push	r14
     d78:	ff 92       	push	r15
     d7a:	0f 93       	push	r16
     d7c:	0f 2e       	mov	r0, r31
     d7e:	fb e3       	ldi	r31, 0x3B	; 59
     d80:	ef 2e       	mov	r14, r31
     d82:	f4 e0       	ldi	r31, 0x04	; 4
     d84:	ff 2e       	mov	r15, r31
     d86:	f0 2d       	mov	r31, r0
     d88:	00 e0       	ldi	r16, 0x00	; 0
     d8a:	20 e0       	ldi	r18, 0x00	; 0
     d8c:	30 e0       	ldi	r19, 0x00	; 0
     d8e:	45 e5       	ldi	r20, 0x55	; 85
     d90:	50 e0       	ldi	r21, 0x00	; 0
     d92:	60 e0       	ldi	r22, 0x00	; 0
     d94:	71 e0       	ldi	r23, 0x01	; 1
     d96:	8b e5       	ldi	r24, 0x5B	; 91
     d98:	98 e0       	ldi	r25, 0x08	; 8
     d9a:	0e 94 67 06 	call	0xcce	; 0xcce <xTaskCreate>
     d9e:	81 30       	cpi	r24, 0x01	; 1
     da0:	81 f4       	brne	.+32     	; 0xdc2 <vTaskStartScheduler+0x4c>
     da2:	f8 94       	cli
     da4:	8f ef       	ldi	r24, 0xFF	; 255
     da6:	9f ef       	ldi	r25, 0xFF	; 255
     da8:	90 93 3e 04 	sts	0x043E, r25	; 0x80043e <xNextTaskUnblockTime+0x1>
     dac:	80 93 3d 04 	sts	0x043D, r24	; 0x80043d <xNextTaskUnblockTime>
     db0:	81 e0       	ldi	r24, 0x01	; 1
     db2:	80 93 43 04 	sts	0x0443, r24	; 0x800443 <xSchedulerRunning>
     db6:	10 92 46 04 	sts	0x0446, r1	; 0x800446 <xTickCount+0x1>
     dba:	10 92 45 04 	sts	0x0445, r1	; 0x800445 <xTickCount>
     dbe:	0e 94 8f 01 	call	0x31e	; 0x31e <xPortStartScheduler>
     dc2:	0f 91       	pop	r16
     dc4:	ff 90       	pop	r15
     dc6:	ef 90       	pop	r14
     dc8:	08 95       	ret

00000dca <vTaskSuspendAll>:
     dca:	80 91 3a 04 	lds	r24, 0x043A	; 0x80043a <uxSchedulerSuspended>
     dce:	8f 5f       	subi	r24, 0xFF	; 255
     dd0:	80 93 3a 04 	sts	0x043A, r24	; 0x80043a <uxSchedulerSuspended>
     dd4:	08 95       	ret

00000dd6 <xTaskIncrementTick>:
     dd6:	df 92       	push	r13
     dd8:	ef 92       	push	r14
     dda:	ff 92       	push	r15
     ddc:	0f 93       	push	r16
     dde:	1f 93       	push	r17
     de0:	cf 93       	push	r28
     de2:	df 93       	push	r29
     de4:	80 91 3a 04 	lds	r24, 0x043A	; 0x80043a <uxSchedulerSuspended>
     de8:	81 11       	cpse	r24, r1
     dea:	97 c0       	rjmp	.+302    	; 0xf1a <xTaskIncrementTick+0x144>
     dec:	e0 90 45 04 	lds	r14, 0x0445	; 0x800445 <xTickCount>
     df0:	f0 90 46 04 	lds	r15, 0x0446	; 0x800446 <xTickCount+0x1>
     df4:	8f ef       	ldi	r24, 0xFF	; 255
     df6:	e8 1a       	sub	r14, r24
     df8:	f8 0a       	sbc	r15, r24
     dfa:	f0 92 46 04 	sts	0x0446, r15	; 0x800446 <xTickCount+0x1>
     dfe:	e0 92 45 04 	sts	0x0445, r14	; 0x800445 <xTickCount>
     e02:	e1 14       	cp	r14, r1
     e04:	f1 04       	cpc	r15, r1
     e06:	b9 f4       	brne	.+46     	; 0xe36 <xTaskIncrementTick+0x60>
     e08:	80 91 66 04 	lds	r24, 0x0466	; 0x800466 <pxDelayedTaskList>
     e0c:	90 91 67 04 	lds	r25, 0x0467	; 0x800467 <pxDelayedTaskList+0x1>
     e10:	20 91 64 04 	lds	r18, 0x0464	; 0x800464 <pxOverflowDelayedTaskList>
     e14:	30 91 65 04 	lds	r19, 0x0465	; 0x800465 <pxOverflowDelayedTaskList+0x1>
     e18:	30 93 67 04 	sts	0x0467, r19	; 0x800467 <pxDelayedTaskList+0x1>
     e1c:	20 93 66 04 	sts	0x0466, r18	; 0x800466 <pxDelayedTaskList>
     e20:	90 93 65 04 	sts	0x0465, r25	; 0x800465 <pxOverflowDelayedTaskList+0x1>
     e24:	80 93 64 04 	sts	0x0464, r24	; 0x800464 <pxOverflowDelayedTaskList>
     e28:	80 91 40 04 	lds	r24, 0x0440	; 0x800440 <xNumOfOverflows>
     e2c:	8f 5f       	subi	r24, 0xFF	; 255
     e2e:	80 93 40 04 	sts	0x0440, r24	; 0x800440 <xNumOfOverflows>
     e32:	0e 94 e6 04 	call	0x9cc	; 0x9cc <prvResetNextTaskUnblockTime>
     e36:	80 91 3d 04 	lds	r24, 0x043D	; 0x80043d <xNextTaskUnblockTime>
     e3a:	90 91 3e 04 	lds	r25, 0x043E	; 0x80043e <xNextTaskUnblockTime+0x1>
     e3e:	e8 16       	cp	r14, r24
     e40:	f9 06       	cpc	r15, r25
     e42:	28 f4       	brcc	.+10     	; 0xe4e <xTaskIncrementTick+0x78>
     e44:	d1 2c       	mov	r13, r1
     e46:	53 c0       	rjmp	.+166    	; 0xeee <xTaskIncrementTick+0x118>
     e48:	dd 24       	eor	r13, r13
     e4a:	d3 94       	inc	r13
     e4c:	01 c0       	rjmp	.+2      	; 0xe50 <xTaskIncrementTick+0x7a>
     e4e:	d1 2c       	mov	r13, r1
     e50:	e0 91 66 04 	lds	r30, 0x0466	; 0x800466 <pxDelayedTaskList>
     e54:	f0 91 67 04 	lds	r31, 0x0467	; 0x800467 <pxDelayedTaskList+0x1>
     e58:	80 81       	ld	r24, Z
     e5a:	81 11       	cpse	r24, r1
     e5c:	07 c0       	rjmp	.+14     	; 0xe6c <xTaskIncrementTick+0x96>
     e5e:	8f ef       	ldi	r24, 0xFF	; 255
     e60:	9f ef       	ldi	r25, 0xFF	; 255
     e62:	90 93 3e 04 	sts	0x043E, r25	; 0x80043e <xNextTaskUnblockTime+0x1>
     e66:	80 93 3d 04 	sts	0x043D, r24	; 0x80043d <xNextTaskUnblockTime>
     e6a:	41 c0       	rjmp	.+130    	; 0xeee <xTaskIncrementTick+0x118>
     e6c:	e0 91 66 04 	lds	r30, 0x0466	; 0x800466 <pxDelayedTaskList>
     e70:	f0 91 67 04 	lds	r31, 0x0467	; 0x800467 <pxDelayedTaskList+0x1>
     e74:	05 80       	ldd	r0, Z+5	; 0x05
     e76:	f6 81       	ldd	r31, Z+6	; 0x06
     e78:	e0 2d       	mov	r30, r0
     e7a:	c6 81       	ldd	r28, Z+6	; 0x06
     e7c:	d7 81       	ldd	r29, Z+7	; 0x07
     e7e:	8a 81       	ldd	r24, Y+2	; 0x02
     e80:	9b 81       	ldd	r25, Y+3	; 0x03
     e82:	e8 16       	cp	r14, r24
     e84:	f9 06       	cpc	r15, r25
     e86:	28 f4       	brcc	.+10     	; 0xe92 <xTaskIncrementTick+0xbc>
     e88:	90 93 3e 04 	sts	0x043E, r25	; 0x80043e <xNextTaskUnblockTime+0x1>
     e8c:	80 93 3d 04 	sts	0x043D, r24	; 0x80043d <xNextTaskUnblockTime>
     e90:	2e c0       	rjmp	.+92     	; 0xeee <xTaskIncrementTick+0x118>
     e92:	8e 01       	movw	r16, r28
     e94:	0e 5f       	subi	r16, 0xFE	; 254
     e96:	1f 4f       	sbci	r17, 0xFF	; 255
     e98:	c8 01       	movw	r24, r16
     e9a:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
     e9e:	8c 89       	ldd	r24, Y+20	; 0x14
     ea0:	9d 89       	ldd	r25, Y+21	; 0x15
     ea2:	89 2b       	or	r24, r25
     ea4:	21 f0       	breq	.+8      	; 0xeae <xTaskIncrementTick+0xd8>
     ea6:	ce 01       	movw	r24, r28
     ea8:	0c 96       	adiw	r24, 0x0c	; 12
     eaa:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
     eae:	8e 89       	ldd	r24, Y+22	; 0x16
     eb0:	90 91 44 04 	lds	r25, 0x0444	; 0x800444 <uxTopReadyPriority>
     eb4:	98 17       	cp	r25, r24
     eb6:	10 f4       	brcc	.+4      	; 0xebc <xTaskIncrementTick+0xe6>
     eb8:	80 93 44 04 	sts	0x0444, r24	; 0x800444 <uxTopReadyPriority>
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	9c 01       	movw	r18, r24
     ec0:	22 0f       	add	r18, r18
     ec2:	33 1f       	adc	r19, r19
     ec4:	22 0f       	add	r18, r18
     ec6:	33 1f       	adc	r19, r19
     ec8:	22 0f       	add	r18, r18
     eca:	33 1f       	adc	r19, r19
     ecc:	82 0f       	add	r24, r18
     ece:	93 1f       	adc	r25, r19
     ed0:	b8 01       	movw	r22, r16
     ed2:	86 58       	subi	r24, 0x86	; 134
     ed4:	9b 4f       	sbci	r25, 0xFB	; 251
     ed6:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
     eda:	9e 89       	ldd	r25, Y+22	; 0x16
     edc:	e0 91 9e 04 	lds	r30, 0x049E	; 0x80049e <pxCurrentTCB>
     ee0:	f0 91 9f 04 	lds	r31, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     ee4:	86 89       	ldd	r24, Z+22	; 0x16
     ee6:	98 17       	cp	r25, r24
     ee8:	08 f0       	brcs	.+2      	; 0xeec <xTaskIncrementTick+0x116>
     eea:	ae cf       	rjmp	.-164    	; 0xe48 <xTaskIncrementTick+0x72>
     eec:	b1 cf       	rjmp	.-158    	; 0xe50 <xTaskIncrementTick+0x7a>
     eee:	e0 91 9e 04 	lds	r30, 0x049E	; 0x80049e <pxCurrentTCB>
     ef2:	f0 91 9f 04 	lds	r31, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     ef6:	86 89       	ldd	r24, Z+22	; 0x16
     ef8:	90 e0       	ldi	r25, 0x00	; 0
     efa:	fc 01       	movw	r30, r24
     efc:	ee 0f       	add	r30, r30
     efe:	ff 1f       	adc	r31, r31
     f00:	ee 0f       	add	r30, r30
     f02:	ff 1f       	adc	r31, r31
     f04:	ee 0f       	add	r30, r30
     f06:	ff 1f       	adc	r31, r31
     f08:	8e 0f       	add	r24, r30
     f0a:	9f 1f       	adc	r25, r31
     f0c:	fc 01       	movw	r30, r24
     f0e:	e6 58       	subi	r30, 0x86	; 134
     f10:	fb 4f       	sbci	r31, 0xFB	; 251
     f12:	80 81       	ld	r24, Z
     f14:	82 30       	cpi	r24, 0x02	; 2
     f16:	40 f4       	brcc	.+16     	; 0xf28 <xTaskIncrementTick+0x152>
     f18:	09 c0       	rjmp	.+18     	; 0xf2c <xTaskIncrementTick+0x156>
     f1a:	80 91 42 04 	lds	r24, 0x0442	; 0x800442 <uxPendedTicks>
     f1e:	8f 5f       	subi	r24, 0xFF	; 255
     f20:	80 93 42 04 	sts	0x0442, r24	; 0x800442 <uxPendedTicks>
     f24:	d1 2c       	mov	r13, r1
     f26:	02 c0       	rjmp	.+4      	; 0xf2c <xTaskIncrementTick+0x156>
     f28:	dd 24       	eor	r13, r13
     f2a:	d3 94       	inc	r13
     f2c:	80 91 41 04 	lds	r24, 0x0441	; 0x800441 <xYieldPending>
     f30:	88 23       	and	r24, r24
     f32:	11 f0       	breq	.+4      	; 0xf38 <xTaskIncrementTick+0x162>
     f34:	dd 24       	eor	r13, r13
     f36:	d3 94       	inc	r13
     f38:	8d 2d       	mov	r24, r13
     f3a:	df 91       	pop	r29
     f3c:	cf 91       	pop	r28
     f3e:	1f 91       	pop	r17
     f40:	0f 91       	pop	r16
     f42:	ff 90       	pop	r15
     f44:	ef 90       	pop	r14
     f46:	df 90       	pop	r13
     f48:	08 95       	ret

00000f4a <xTaskResumeAll>:
     f4a:	0f 93       	push	r16
     f4c:	1f 93       	push	r17
     f4e:	cf 93       	push	r28
     f50:	df 93       	push	r29
     f52:	0f b6       	in	r0, 0x3f	; 63
     f54:	f8 94       	cli
     f56:	0f 92       	push	r0
     f58:	80 91 3a 04 	lds	r24, 0x043A	; 0x80043a <uxSchedulerSuspended>
     f5c:	81 50       	subi	r24, 0x01	; 1
     f5e:	80 93 3a 04 	sts	0x043A, r24	; 0x80043a <uxSchedulerSuspended>
     f62:	80 91 3a 04 	lds	r24, 0x043A	; 0x80043a <uxSchedulerSuspended>
     f66:	81 11       	cpse	r24, r1
     f68:	58 c0       	rjmp	.+176    	; 0x101a <xTaskResumeAll+0xd0>
     f6a:	80 91 47 04 	lds	r24, 0x0447	; 0x800447 <uxCurrentNumberOfTasks>
     f6e:	81 11       	cpse	r24, r1
     f70:	33 c0       	rjmp	.+102    	; 0xfd8 <xTaskResumeAll+0x8e>
     f72:	56 c0       	rjmp	.+172    	; 0x1020 <xTaskResumeAll+0xd6>
     f74:	e0 91 60 04 	lds	r30, 0x0460	; 0x800460 <xPendingReadyList+0x5>
     f78:	f0 91 61 04 	lds	r31, 0x0461	; 0x800461 <xPendingReadyList+0x6>
     f7c:	c6 81       	ldd	r28, Z+6	; 0x06
     f7e:	d7 81       	ldd	r29, Z+7	; 0x07
     f80:	ce 01       	movw	r24, r28
     f82:	0c 96       	adiw	r24, 0x0c	; 12
     f84:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
     f88:	8e 01       	movw	r16, r28
     f8a:	0e 5f       	subi	r16, 0xFE	; 254
     f8c:	1f 4f       	sbci	r17, 0xFF	; 255
     f8e:	c8 01       	movw	r24, r16
     f90:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
     f94:	8e 89       	ldd	r24, Y+22	; 0x16
     f96:	90 91 44 04 	lds	r25, 0x0444	; 0x800444 <uxTopReadyPriority>
     f9a:	98 17       	cp	r25, r24
     f9c:	10 f4       	brcc	.+4      	; 0xfa2 <xTaskResumeAll+0x58>
     f9e:	80 93 44 04 	sts	0x0444, r24	; 0x800444 <uxTopReadyPriority>
     fa2:	90 e0       	ldi	r25, 0x00	; 0
     fa4:	9c 01       	movw	r18, r24
     fa6:	22 0f       	add	r18, r18
     fa8:	33 1f       	adc	r19, r19
     faa:	22 0f       	add	r18, r18
     fac:	33 1f       	adc	r19, r19
     fae:	22 0f       	add	r18, r18
     fb0:	33 1f       	adc	r19, r19
     fb2:	82 0f       	add	r24, r18
     fb4:	93 1f       	adc	r25, r19
     fb6:	b8 01       	movw	r22, r16
     fb8:	86 58       	subi	r24, 0x86	; 134
     fba:	9b 4f       	sbci	r25, 0xFB	; 251
     fbc:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
     fc0:	9e 89       	ldd	r25, Y+22	; 0x16
     fc2:	e0 91 9e 04 	lds	r30, 0x049E	; 0x80049e <pxCurrentTCB>
     fc6:	f0 91 9f 04 	lds	r31, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
     fca:	86 89       	ldd	r24, Z+22	; 0x16
     fcc:	98 17       	cp	r25, r24
     fce:	30 f0       	brcs	.+12     	; 0xfdc <xTaskResumeAll+0x92>
     fd0:	81 e0       	ldi	r24, 0x01	; 1
     fd2:	80 93 41 04 	sts	0x0441, r24	; 0x800441 <xYieldPending>
     fd6:	02 c0       	rjmp	.+4      	; 0xfdc <xTaskResumeAll+0x92>
     fd8:	c0 e0       	ldi	r28, 0x00	; 0
     fda:	d0 e0       	ldi	r29, 0x00	; 0
     fdc:	80 91 5b 04 	lds	r24, 0x045B	; 0x80045b <xPendingReadyList>
     fe0:	81 11       	cpse	r24, r1
     fe2:	c8 cf       	rjmp	.-112    	; 0xf74 <xTaskResumeAll+0x2a>
     fe4:	cd 2b       	or	r28, r29
     fe6:	11 f0       	breq	.+4      	; 0xfec <xTaskResumeAll+0xa2>
     fe8:	0e 94 e6 04 	call	0x9cc	; 0x9cc <prvResetNextTaskUnblockTime>
     fec:	c0 91 42 04 	lds	r28, 0x0442	; 0x800442 <uxPendedTicks>
     ff0:	cc 23       	and	r28, r28
     ff2:	59 f0       	breq	.+22     	; 0x100a <xTaskResumeAll+0xc0>
     ff4:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <xTaskIncrementTick>
     ff8:	88 23       	and	r24, r24
     ffa:	19 f0       	breq	.+6      	; 0x1002 <xTaskResumeAll+0xb8>
     ffc:	81 e0       	ldi	r24, 0x01	; 1
     ffe:	80 93 41 04 	sts	0x0441, r24	; 0x800441 <xYieldPending>
    1002:	c1 50       	subi	r28, 0x01	; 1
    1004:	b9 f7       	brne	.-18     	; 0xff4 <xTaskResumeAll+0xaa>
    1006:	10 92 42 04 	sts	0x0442, r1	; 0x800442 <uxPendedTicks>
    100a:	80 91 41 04 	lds	r24, 0x0441	; 0x800441 <xYieldPending>
    100e:	88 23       	and	r24, r24
    1010:	31 f0       	breq	.+12     	; 0x101e <xTaskResumeAll+0xd4>
    1012:	0e 94 be 01 	call	0x37c	; 0x37c <vPortYield>
    1016:	81 e0       	ldi	r24, 0x01	; 1
    1018:	03 c0       	rjmp	.+6      	; 0x1020 <xTaskResumeAll+0xd6>
    101a:	80 e0       	ldi	r24, 0x00	; 0
    101c:	01 c0       	rjmp	.+2      	; 0x1020 <xTaskResumeAll+0xd6>
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	0f 90       	pop	r0
    1022:	0f be       	out	0x3f, r0	; 63
    1024:	df 91       	pop	r29
    1026:	cf 91       	pop	r28
    1028:	1f 91       	pop	r17
    102a:	0f 91       	pop	r16
    102c:	08 95       	ret

0000102e <vTaskDelay>:
    102e:	cf 93       	push	r28
    1030:	df 93       	push	r29
    1032:	ec 01       	movw	r28, r24
    1034:	89 2b       	or	r24, r25
    1036:	49 f0       	breq	.+18     	; 0x104a <vTaskDelay+0x1c>
    1038:	0e 94 e5 06 	call	0xdca	; 0xdca <vTaskSuspendAll>
    103c:	60 e0       	ldi	r22, 0x00	; 0
    103e:	ce 01       	movw	r24, r28
    1040:	0e 94 0f 06 	call	0xc1e	; 0xc1e <prvAddCurrentTaskToDelayedList>
    1044:	0e 94 a5 07 	call	0xf4a	; 0xf4a <xTaskResumeAll>
    1048:	01 c0       	rjmp	.+2      	; 0x104c <vTaskDelay+0x1e>
    104a:	80 e0       	ldi	r24, 0x00	; 0
    104c:	81 11       	cpse	r24, r1
    104e:	02 c0       	rjmp	.+4      	; 0x1054 <vTaskDelay+0x26>
    1050:	0e 94 be 01 	call	0x37c	; 0x37c <vPortYield>
    1054:	df 91       	pop	r29
    1056:	cf 91       	pop	r28
    1058:	08 95       	ret

0000105a <prvCheckTasksWaitingTermination>:
    105a:	cf 93       	push	r28
    105c:	df 93       	push	r29
    105e:	24 c0       	rjmp	.+72     	; 0x10a8 <prvCheckTasksWaitingTermination+0x4e>
    1060:	0e 94 e5 06 	call	0xdca	; 0xdca <vTaskSuspendAll>
    1064:	c0 91 52 04 	lds	r28, 0x0452	; 0x800452 <xTasksWaitingTermination>
    1068:	0e 94 a5 07 	call	0xf4a	; 0xf4a <xTaskResumeAll>
    106c:	cc 23       	and	r28, r28
    106e:	e1 f0       	breq	.+56     	; 0x10a8 <prvCheckTasksWaitingTermination+0x4e>
    1070:	0f b6       	in	r0, 0x3f	; 63
    1072:	f8 94       	cli
    1074:	0f 92       	push	r0
    1076:	e0 91 57 04 	lds	r30, 0x0457	; 0x800457 <xTasksWaitingTermination+0x5>
    107a:	f0 91 58 04 	lds	r31, 0x0458	; 0x800458 <xTasksWaitingTermination+0x6>
    107e:	c6 81       	ldd	r28, Z+6	; 0x06
    1080:	d7 81       	ldd	r29, Z+7	; 0x07
    1082:	ce 01       	movw	r24, r28
    1084:	02 96       	adiw	r24, 0x02	; 2
    1086:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
    108a:	80 91 47 04 	lds	r24, 0x0447	; 0x800447 <uxCurrentNumberOfTasks>
    108e:	81 50       	subi	r24, 0x01	; 1
    1090:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <uxCurrentNumberOfTasks>
    1094:	80 91 51 04 	lds	r24, 0x0451	; 0x800451 <uxDeletedTasksWaitingCleanUp>
    1098:	81 50       	subi	r24, 0x01	; 1
    109a:	80 93 51 04 	sts	0x0451, r24	; 0x800451 <uxDeletedTasksWaitingCleanUp>
    109e:	0f 90       	pop	r0
    10a0:	0f be       	out	0x3f, r0	; 63
    10a2:	ce 01       	movw	r24, r28
    10a4:	0e 94 05 05 	call	0xa0a	; 0xa0a <prvDeleteTCB>
    10a8:	80 91 51 04 	lds	r24, 0x0451	; 0x800451 <uxDeletedTasksWaitingCleanUp>
    10ac:	81 11       	cpse	r24, r1
    10ae:	d8 cf       	rjmp	.-80     	; 0x1060 <prvCheckTasksWaitingTermination+0x6>
    10b0:	df 91       	pop	r29
    10b2:	cf 91       	pop	r28
    10b4:	08 95       	ret

000010b6 <prvIdleTask>:
    10b6:	0e 94 2d 08 	call	0x105a	; 0x105a <prvCheckTasksWaitingTermination>
    10ba:	80 91 7a 04 	lds	r24, 0x047A	; 0x80047a <pxReadyTasksLists>
    10be:	82 30       	cpi	r24, 0x02	; 2
    10c0:	d0 f3       	brcs	.-12     	; 0x10b6 <prvIdleTask>
    10c2:	0e 94 be 01 	call	0x37c	; 0x37c <vPortYield>
    10c6:	f7 cf       	rjmp	.-18     	; 0x10b6 <prvIdleTask>

000010c8 <vTaskSwitchContext>:
    10c8:	80 91 3a 04 	lds	r24, 0x043A	; 0x80043a <uxSchedulerSuspended>
    10cc:	88 23       	and	r24, r24
    10ce:	21 f0       	breq	.+8      	; 0x10d8 <vTaskSwitchContext+0x10>
    10d0:	81 e0       	ldi	r24, 0x01	; 1
    10d2:	80 93 41 04 	sts	0x0441, r24	; 0x800441 <xYieldPending>
    10d6:	08 95       	ret
    10d8:	10 92 41 04 	sts	0x0441, r1	; 0x800441 <xYieldPending>
    10dc:	20 91 44 04 	lds	r18, 0x0444	; 0x800444 <uxTopReadyPriority>
    10e0:	01 c0       	rjmp	.+2      	; 0x10e4 <vTaskSwitchContext+0x1c>
    10e2:	21 50       	subi	r18, 0x01	; 1
    10e4:	82 2f       	mov	r24, r18
    10e6:	90 e0       	ldi	r25, 0x00	; 0
    10e8:	fc 01       	movw	r30, r24
    10ea:	ee 0f       	add	r30, r30
    10ec:	ff 1f       	adc	r31, r31
    10ee:	ee 0f       	add	r30, r30
    10f0:	ff 1f       	adc	r31, r31
    10f2:	ee 0f       	add	r30, r30
    10f4:	ff 1f       	adc	r31, r31
    10f6:	e8 0f       	add	r30, r24
    10f8:	f9 1f       	adc	r31, r25
    10fa:	e6 58       	subi	r30, 0x86	; 134
    10fc:	fb 4f       	sbci	r31, 0xFB	; 251
    10fe:	30 81       	ld	r19, Z
    1100:	33 23       	and	r19, r19
    1102:	79 f3       	breq	.-34     	; 0x10e2 <vTaskSwitchContext+0x1a>
    1104:	ac 01       	movw	r20, r24
    1106:	44 0f       	add	r20, r20
    1108:	55 1f       	adc	r21, r21
    110a:	44 0f       	add	r20, r20
    110c:	55 1f       	adc	r21, r21
    110e:	44 0f       	add	r20, r20
    1110:	55 1f       	adc	r21, r21
    1112:	48 0f       	add	r20, r24
    1114:	59 1f       	adc	r21, r25
    1116:	df 01       	movw	r26, r30
    1118:	01 80       	ldd	r0, Z+1	; 0x01
    111a:	f2 81       	ldd	r31, Z+2	; 0x02
    111c:	e0 2d       	mov	r30, r0
    111e:	02 80       	ldd	r0, Z+2	; 0x02
    1120:	f3 81       	ldd	r31, Z+3	; 0x03
    1122:	e0 2d       	mov	r30, r0
    1124:	12 96       	adiw	r26, 0x02	; 2
    1126:	fc 93       	st	X, r31
    1128:	ee 93       	st	-X, r30
    112a:	11 97       	sbiw	r26, 0x01	; 1
    112c:	43 58       	subi	r20, 0x83	; 131
    112e:	5b 4f       	sbci	r21, 0xFB	; 251
    1130:	e4 17       	cp	r30, r20
    1132:	f5 07       	cpc	r31, r21
    1134:	29 f4       	brne	.+10     	; 0x1140 <vTaskSwitchContext+0x78>
    1136:	42 81       	ldd	r20, Z+2	; 0x02
    1138:	53 81       	ldd	r21, Z+3	; 0x03
    113a:	fd 01       	movw	r30, r26
    113c:	52 83       	std	Z+2, r21	; 0x02
    113e:	41 83       	std	Z+1, r20	; 0x01
    1140:	fc 01       	movw	r30, r24
    1142:	ee 0f       	add	r30, r30
    1144:	ff 1f       	adc	r31, r31
    1146:	ee 0f       	add	r30, r30
    1148:	ff 1f       	adc	r31, r31
    114a:	ee 0f       	add	r30, r30
    114c:	ff 1f       	adc	r31, r31
    114e:	8e 0f       	add	r24, r30
    1150:	9f 1f       	adc	r25, r31
    1152:	fc 01       	movw	r30, r24
    1154:	e6 58       	subi	r30, 0x86	; 134
    1156:	fb 4f       	sbci	r31, 0xFB	; 251
    1158:	01 80       	ldd	r0, Z+1	; 0x01
    115a:	f2 81       	ldd	r31, Z+2	; 0x02
    115c:	e0 2d       	mov	r30, r0
    115e:	86 81       	ldd	r24, Z+6	; 0x06
    1160:	97 81       	ldd	r25, Z+7	; 0x07
    1162:	90 93 9f 04 	sts	0x049F, r25	; 0x80049f <pxCurrentTCB+0x1>
    1166:	80 93 9e 04 	sts	0x049E, r24	; 0x80049e <pxCurrentTCB>
    116a:	20 93 44 04 	sts	0x0444, r18	; 0x800444 <uxTopReadyPriority>
    116e:	08 95       	ret

00001170 <vTaskPlaceOnEventList>:
    1170:	cf 93       	push	r28
    1172:	df 93       	push	r29
    1174:	eb 01       	movw	r28, r22
    1176:	60 91 9e 04 	lds	r22, 0x049E	; 0x80049e <pxCurrentTCB>
    117a:	70 91 9f 04 	lds	r23, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
    117e:	64 5f       	subi	r22, 0xF4	; 244
    1180:	7f 4f       	sbci	r23, 0xFF	; 255
    1182:	0e 94 bc 00 	call	0x178	; 0x178 <vListInsert>
    1186:	61 e0       	ldi	r22, 0x01	; 1
    1188:	ce 01       	movw	r24, r28
    118a:	0e 94 0f 06 	call	0xc1e	; 0xc1e <prvAddCurrentTaskToDelayedList>
    118e:	df 91       	pop	r29
    1190:	cf 91       	pop	r28
    1192:	08 95       	ret

00001194 <xTaskRemoveFromEventList>:
    1194:	0f 93       	push	r16
    1196:	1f 93       	push	r17
    1198:	cf 93       	push	r28
    119a:	df 93       	push	r29
    119c:	dc 01       	movw	r26, r24
    119e:	15 96       	adiw	r26, 0x05	; 5
    11a0:	ed 91       	ld	r30, X+
    11a2:	fc 91       	ld	r31, X
    11a4:	16 97       	sbiw	r26, 0x06	; 6
    11a6:	c6 81       	ldd	r28, Z+6	; 0x06
    11a8:	d7 81       	ldd	r29, Z+7	; 0x07
    11aa:	8e 01       	movw	r16, r28
    11ac:	04 5f       	subi	r16, 0xF4	; 244
    11ae:	1f 4f       	sbci	r17, 0xFF	; 255
    11b0:	c8 01       	movw	r24, r16
    11b2:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
    11b6:	80 91 3a 04 	lds	r24, 0x043A	; 0x80043a <uxSchedulerSuspended>
    11ba:	81 11       	cpse	r24, r1
    11bc:	1c c0       	rjmp	.+56     	; 0x11f6 <xTaskRemoveFromEventList+0x62>
    11be:	0a 50       	subi	r16, 0x0A	; 10
    11c0:	11 09       	sbc	r17, r1
    11c2:	c8 01       	movw	r24, r16
    11c4:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
    11c8:	8e 89       	ldd	r24, Y+22	; 0x16
    11ca:	90 91 44 04 	lds	r25, 0x0444	; 0x800444 <uxTopReadyPriority>
    11ce:	98 17       	cp	r25, r24
    11d0:	10 f4       	brcc	.+4      	; 0x11d6 <xTaskRemoveFromEventList+0x42>
    11d2:	80 93 44 04 	sts	0x0444, r24	; 0x800444 <uxTopReadyPriority>
    11d6:	90 e0       	ldi	r25, 0x00	; 0
    11d8:	9c 01       	movw	r18, r24
    11da:	22 0f       	add	r18, r18
    11dc:	33 1f       	adc	r19, r19
    11de:	22 0f       	add	r18, r18
    11e0:	33 1f       	adc	r19, r19
    11e2:	22 0f       	add	r18, r18
    11e4:	33 1f       	adc	r19, r19
    11e6:	82 0f       	add	r24, r18
    11e8:	93 1f       	adc	r25, r19
    11ea:	b8 01       	movw	r22, r16
    11ec:	86 58       	subi	r24, 0x86	; 134
    11ee:	9b 4f       	sbci	r25, 0xFB	; 251
    11f0:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
    11f4:	05 c0       	rjmp	.+10     	; 0x1200 <xTaskRemoveFromEventList+0x6c>
    11f6:	b8 01       	movw	r22, r16
    11f8:	8b e5       	ldi	r24, 0x5B	; 91
    11fa:	94 e0       	ldi	r25, 0x04	; 4
    11fc:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
    1200:	9e 89       	ldd	r25, Y+22	; 0x16
    1202:	e0 91 9e 04 	lds	r30, 0x049E	; 0x80049e <pxCurrentTCB>
    1206:	f0 91 9f 04 	lds	r31, 0x049F	; 0x80049f <pxCurrentTCB+0x1>
    120a:	86 89       	ldd	r24, Z+22	; 0x16
    120c:	89 17       	cp	r24, r25
    120e:	20 f4       	brcc	.+8      	; 0x1218 <xTaskRemoveFromEventList+0x84>
    1210:	81 e0       	ldi	r24, 0x01	; 1
    1212:	80 93 41 04 	sts	0x0441, r24	; 0x800441 <xYieldPending>
    1216:	01 c0       	rjmp	.+2      	; 0x121a <xTaskRemoveFromEventList+0x86>
    1218:	80 e0       	ldi	r24, 0x00	; 0
    121a:	df 91       	pop	r29
    121c:	cf 91       	pop	r28
    121e:	1f 91       	pop	r17
    1220:	0f 91       	pop	r16
    1222:	08 95       	ret

00001224 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1224:	20 91 40 04 	lds	r18, 0x0440	; 0x800440 <xNumOfOverflows>
    1228:	fc 01       	movw	r30, r24
    122a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    122c:	20 91 45 04 	lds	r18, 0x0445	; 0x800445 <xTickCount>
    1230:	30 91 46 04 	lds	r19, 0x0446	; 0x800446 <xTickCount+0x1>
    1234:	32 83       	std	Z+2, r19	; 0x02
    1236:	21 83       	std	Z+1, r18	; 0x01
    1238:	08 95       	ret

0000123a <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    123a:	0f b6       	in	r0, 0x3f	; 63
    123c:	f8 94       	cli
    123e:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1240:	40 91 45 04 	lds	r20, 0x0445	; 0x800445 <xTickCount>
    1244:	50 91 46 04 	lds	r21, 0x0446	; 0x800446 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    1248:	db 01       	movw	r26, r22
    124a:	2d 91       	ld	r18, X+
    124c:	3c 91       	ld	r19, X
    124e:	2f 3f       	cpi	r18, 0xFF	; 255
    1250:	bf ef       	ldi	r27, 0xFF	; 255
    1252:	3b 07       	cpc	r19, r27
    1254:	19 f1       	breq	.+70     	; 0x129c <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1256:	dc 01       	movw	r26, r24
    1258:	fc 91       	ld	r31, X
    125a:	e0 91 40 04 	lds	r30, 0x0440	; 0x800440 <xNumOfOverflows>
    125e:	fe 17       	cp	r31, r30
    1260:	39 f0       	breq	.+14     	; 0x1270 <xTaskCheckForTimeOut+0x36>
    1262:	11 96       	adiw	r26, 0x01	; 1
    1264:	ed 91       	ld	r30, X+
    1266:	fc 91       	ld	r31, X
    1268:	12 97       	sbiw	r26, 0x02	; 2
    126a:	4e 17       	cp	r20, r30
    126c:	5f 07       	cpc	r21, r31
    126e:	c0 f4       	brcc	.+48     	; 0x12a0 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1270:	dc 01       	movw	r26, r24
    1272:	11 96       	adiw	r26, 0x01	; 1
    1274:	ed 91       	ld	r30, X+
    1276:	fc 91       	ld	r31, X
    1278:	12 97       	sbiw	r26, 0x02	; 2
    127a:	da 01       	movw	r26, r20
    127c:	ae 1b       	sub	r26, r30
    127e:	bf 0b       	sbc	r27, r31
    1280:	a2 17       	cp	r26, r18
    1282:	b3 07       	cpc	r27, r19
    1284:	78 f4       	brcc	.+30     	; 0x12a4 <xTaskCheckForTimeOut+0x6a>
    1286:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    1288:	e4 1b       	sub	r30, r20
    128a:	f5 0b       	sbc	r31, r21
    128c:	2e 0f       	add	r18, r30
    128e:	3f 1f       	adc	r19, r31
    1290:	2d 93       	st	X+, r18
    1292:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1294:	0e 94 12 09 	call	0x1224	; 0x1224 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1298:	80 e0       	ldi	r24, 0x00	; 0
    129a:	05 c0       	rjmp	.+10     	; 0x12a6 <xTaskCheckForTimeOut+0x6c>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    129c:	80 e0       	ldi	r24, 0x00	; 0
    129e:	03 c0       	rjmp	.+6      	; 0x12a6 <xTaskCheckForTimeOut+0x6c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    12a0:	81 e0       	ldi	r24, 0x01	; 1
    12a2:	01 c0       	rjmp	.+2      	; 0x12a6 <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    12a4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    12a6:	0f 90       	pop	r0
    12a8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    12aa:	08 95       	ret

000012ac <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    12ac:	81 e0       	ldi	r24, 0x01	; 1
    12ae:	80 93 41 04 	sts	0x0441, r24	; 0x800441 <xYieldPending>
    12b2:	08 95       	ret

000012b4 <calculate_checksum>:
 * @brief PDF    . 
 * @param buffer '$'    (ID Checksum )
 * @param length     
 * @return  
 */
static uint8_t calculate_checksum(uint8_t *buffer, uint8_t length) {
    12b4:	ac 01       	movw	r20, r24
    uint8_t sum = 0;
    for (uint8_t i = 0; i < length; i++) {
    12b6:	90 e0       	ldi	r25, 0x00	; 0
 * @param buffer '$'    (ID Checksum )
 * @param length     
 * @return  
 */
static uint8_t calculate_checksum(uint8_t *buffer, uint8_t length) {
    uint8_t sum = 0;
    12b8:	80 e0       	ldi	r24, 0x00	; 0
    for (uint8_t i = 0; i < length; i++) {
    12ba:	06 c0       	rjmp	.+12     	; 0x12c8 <calculate_checksum+0x14>
        sum += buffer[i];
    12bc:	fa 01       	movw	r30, r20
    12be:	e9 0f       	add	r30, r25
    12c0:	f1 1d       	adc	r31, r1
    12c2:	20 81       	ld	r18, Z
    12c4:	82 0f       	add	r24, r18
 * @param length     
 * @return  
 */
static uint8_t calculate_checksum(uint8_t *buffer, uint8_t length) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < length; i++) {
    12c6:	9f 5f       	subi	r25, 0xFF	; 255
    12c8:	96 17       	cp	r25, r22
    12ca:	c0 f3       	brcs	.-16     	; 0x12bc <calculate_checksum+0x8>
        sum += buffer[i];
    }
    return sum;
}
    12cc:	08 95       	ret

000012ce <vRxTask>:

/**
 * @brief Rx Task:    -> FreeRTOS  (  )
 * ISR        .
 */
void vRxTask(void *pvParameters) {
    12ce:	cf 93       	push	r28
    12d0:	df 93       	push	r29
    12d2:	1f 92       	push	r1
    12d4:	cd b7       	in	r28, 0x3d	; 61
    12d6:	de b7       	in	r29, 0x3e	; 62
    uint8_t received_char;
    
    while (1) {
        // uart_rx()  vTaskDelay(1) 
        //    CPU .
        received_char = uart_rx(); 
    12d8:	0e 94 20 0b 	call	0x1640	; 0x1640 <uart_rx>
    12dc:	89 83       	std	Y+1, r24	; 0x01
        
        //  FreeRTOS   ( 10ms )
        if (xQueueSend(xUartQueue, &received_char, pdMS_TO_TICKS(10)) != pdPASS) {
    12de:	20 e0       	ldi	r18, 0x00	; 0
    12e0:	4a e0       	ldi	r20, 0x0A	; 10
    12e2:	50 e0       	ldi	r21, 0x00	; 0
    12e4:	be 01       	movw	r22, r28
    12e6:	6f 5f       	subi	r22, 0xFF	; 255
    12e8:	7f 4f       	sbci	r23, 0xFF	; 255
    12ea:	80 91 b0 04 	lds	r24, 0x04B0	; 0x8004b0 <xUartQueue>
    12ee:	90 91 b1 04 	lds	r25, 0x04B1	; 0x8004b1 <xUartQueue+0x1>
    12f2:	0e 94 ab 03 	call	0x756	; 0x756 <xQueueGenericSend>
    12f6:	f0 cf       	rjmp	.-32     	; 0x12d8 <vRxTask+0xa>

000012f8 <send_response>:
 * @param slave_id  Slave ID
 * @param cmd 'W'  'R'
 * @param addr  
 * @param data 'R'    , 'W'    
 */
static void send_response(uint8_t slave_id, uint8_t cmd, uint8_t addr, uint8_t data) {
    12f8:	1f 93       	push	r17
    12fa:	cf 93       	push	r28
    12fc:	df 93       	push	r29
    12fe:	cd b7       	in	r28, 0x3d	; 61
    1300:	de b7       	in	r29, 0x3e	; 62
    1302:	27 97       	sbiw	r28, 0x07	; 7
    1304:	0f b6       	in	r0, 0x3f	; 63
    1306:	f8 94       	cli
    1308:	de bf       	out	0x3e, r29	; 62
    130a:	0f be       	out	0x3f, r0	; 63
    130c:	cd bf       	out	0x3d, r28	; 61
    uint8_t response[7]; //   (7 )
    uint8_t checksum;

    response[0] = '$';
    130e:	94 e2       	ldi	r25, 0x24	; 36
    1310:	99 83       	std	Y+1, r25	; 0x01
    response[1] = slave_id;
    1312:	8a 83       	std	Y+2, r24	; 0x02
    response[2] = cmd;
    1314:	6b 83       	std	Y+3, r22	; 0x03
    response[3] = addr;
    1316:	4c 83       	std	Y+4, r20	; 0x04
    response[4] = data; // R     
    1318:	2d 83       	std	Y+5, r18	; 0x05
    
    //  : ID   
    checksum = calculate_checksum(&response[1], 4); 
    131a:	64 e0       	ldi	r22, 0x04	; 4
    131c:	ce 01       	movw	r24, r28
    131e:	02 96       	adiw	r24, 0x02	; 2
    1320:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <calculate_checksum>
    
    response[5] = checksum;
    1324:	8e 83       	std	Y+6, r24	; 0x06
    response[6] = '\n';
    1326:	8a e0       	ldi	r24, 0x0A	; 10
    1328:	8f 83       	std	Y+7, r24	; 0x07

    // uart_tx  RS-485    .
    for (uint8_t i = 0; i < 7; i++) {
    132a:	10 e0       	ldi	r17, 0x00	; 0
    132c:	0a c0       	rjmp	.+20     	; 0x1342 <send_response+0x4a>
        uart_tx(response[i]);
    132e:	e1 e0       	ldi	r30, 0x01	; 1
    1330:	f0 e0       	ldi	r31, 0x00	; 0
    1332:	ec 0f       	add	r30, r28
    1334:	fd 1f       	adc	r31, r29
    1336:	e1 0f       	add	r30, r17
    1338:	f1 1d       	adc	r31, r1
    133a:	80 81       	ld	r24, Z
    133c:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <uart_tx>
    
    response[5] = checksum;
    response[6] = '\n';

    // uart_tx  RS-485    .
    for (uint8_t i = 0; i < 7; i++) {
    1340:	1f 5f       	subi	r17, 0xFF	; 255
    1342:	17 30       	cpi	r17, 0x07	; 7
    1344:	a0 f3       	brcs	.-24     	; 0x132e <send_response+0x36>
        uart_tx(response[i]);
    }
}
    1346:	27 96       	adiw	r28, 0x07	; 7
    1348:	0f b6       	in	r0, 0x3f	; 63
    134a:	f8 94       	cli
    134c:	de bf       	out	0x3e, r29	; 62
    134e:	0f be       	out	0x3f, r0	; 63
    1350:	cd bf       	out	0x3d, r28	; 61
    1352:	df 91       	pop	r29
    1354:	cf 91       	pop	r28
    1356:	1f 91       	pop	r17
    1358:	08 95       	ret

0000135a <process_packet>:
/**
 * @brief    . (Slave ) 
 * @param buffer    ('$'...'\n' )
 * @param length   
 */
static void process_packet(uint8_t *buffer, uint8_t length) {
    135a:	ef 92       	push	r14
    135c:	ff 92       	push	r15
    135e:	0f 93       	push	r16
    1360:	1f 93       	push	r17
    1362:	cf 93       	push	r28
    1364:	df 93       	push	r29
    // 1.    (W: 7, R: 6)
    if (length < 6) return; //  
    1366:	66 30       	cpi	r22, 0x06	; 6
    1368:	08 f4       	brcc	.+2      	; 0x136c <process_packet+0x12>
    136a:	40 c0       	rjmp	.+128    	; 0x13ec <process_packet+0x92>

    // 2. Slave ID 
    uint8_t slave_id = buffer[FRAME_IDX_ID];
    136c:	fc 01       	movw	r30, r24
    136e:	11 81       	ldd	r17, Z+1	; 0x01
    if (slave_id != MY_SLAVE_ID) {
    1370:	11 30       	cpi	r17, 0x01	; 1
    1372:	e1 f5       	brne	.+120    	; 0x13ec <process_packet+0x92>
        return; //     
    }

    // 3.   
    uint8_t cmd = buffer[FRAME_IDX_CMD];
    1374:	02 81       	ldd	r16, Z+2	; 0x02
    uint8_t addr = buffer[FRAME_IDX_ADDR];
    1376:	f3 80       	ldd	r15, Z+3	; 0x03
    uint8_t received_checksum;
    uint8_t calculated_checksum;
    uint8_t data_len_for_checksum;

    if (cmd == 'W') {
    1378:	07 35       	cpi	r16, 0x57	; 87
    137a:	29 f4       	brne	.+10     	; 0x1386 <process_packet+0x2c>
        
		if (length != 7) return; // 'W'  7  
    137c:	67 30       	cpi	r22, 0x07	; 7
    137e:	b1 f5       	brne	.+108    	; 0x13ec <process_packet+0x92>
        received_checksum = buffer[FRAME_IDX_W_CHECKSUM];
    1380:	e5 80       	ldd	r14, Z+5	; 0x05
        data_len_for_checksum = 4; // ID, Cmd, Addr, Data
    1382:	64 e0       	ldi	r22, 0x04	; 4
    1384:	0b c0       	rjmp	.+22     	; 0x139c <process_packet+0x42>
		
    } else if (cmd == 'R') {
    1386:	02 35       	cpi	r16, 0x52	; 82
    1388:	89 f5       	brne	.+98     	; 0x13ec <process_packet+0x92>
        
		if (length != 6) return; // 'R'  6   (Data  )
    138a:	66 30       	cpi	r22, 0x06	; 6
    138c:	79 f5       	brne	.+94     	; 0x13ec <process_packet+0x92>
        received_checksum = buffer[length - 2]; // Checksum \n  
    138e:	e6 2f       	mov	r30, r22
    1390:	f0 e0       	ldi	r31, 0x00	; 0
    1392:	32 97       	sbiw	r30, 0x02	; 2
    1394:	e8 0f       	add	r30, r24
    1396:	f9 1f       	adc	r31, r25
    1398:	e0 80       	ld	r14, Z
		data_len_for_checksum = 3; // ID, Cmd, Addr
    139a:	63 e0       	ldi	r22, 0x03	; 3
    139c:	ec 01       	movw	r28, r24
		
    } else {
        return; //    
    }
    
    calculated_checksum = calculate_checksum(&buffer[FRAME_IDX_ID], data_len_for_checksum);
    139e:	01 96       	adiw	r24, 0x01	; 1
    13a0:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <calculate_checksum>

    if (received_checksum != calculated_checksum) {
    13a4:	e8 12       	cpse	r14, r24
    13a6:	22 c0       	rjmp	.+68     	; 0x13ec <process_packet+0x92>
        return; //  
    }else{
		// 4.    ->  
		uint8_t data;
		if (cmd == 'W') {
    13a8:	07 35       	cpi	r16, 0x57	; 87
    13aa:	79 f4       	brne	.+30     	; 0x13ca <process_packet+0x70>
			data = buffer[FRAME_IDX_W_DATA];
    13ac:	2c 81       	ldd	r18, Y+4	; 0x04
			if (addr < 16) { //    
    13ae:	ff e0       	ldi	r31, 0x0F	; 15
    13b0:	ff 15       	cp	r31, r15
    13b2:	28 f0       	brcs	.+10     	; 0x13be <process_packet+0x64>
				g_device_registers[addr] = data;
    13b4:	ef 2d       	mov	r30, r15
    13b6:	f0 e0       	ldi	r31, 0x00	; 0
    13b8:	e0 56       	subi	r30, 0x60	; 96
    13ba:	fb 4f       	sbci	r31, 0xFB	; 251
    13bc:	20 83       	st	Z, r18
			}
			// 'W'   
			send_response(slave_id, cmd, addr, data);
    13be:	4f 2d       	mov	r20, r15
    13c0:	60 2f       	mov	r22, r16
    13c2:	81 2f       	mov	r24, r17
    13c4:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <send_response>
    13c8:	11 c0       	rjmp	.+34     	; 0x13ec <process_packet+0x92>
			    
			} else if (cmd == 'R') {
    13ca:	02 35       	cpi	r16, 0x52	; 82
    13cc:	79 f4       	brne	.+30     	; 0x13ec <process_packet+0x92>
				data = 0;
				if (addr < 16) { //    
    13ce:	8f e0       	ldi	r24, 0x0F	; 15
    13d0:	8f 15       	cp	r24, r15
    13d2:	30 f0       	brcs	.+12     	; 0x13e0 <process_packet+0x86>
					data = g_device_registers[addr];
    13d4:	ef 2d       	mov	r30, r15
    13d6:	f0 e0       	ldi	r31, 0x00	; 0
    13d8:	e0 56       	subi	r30, 0x60	; 96
    13da:	fb 4f       	sbci	r31, 0xFB	; 251
    13dc:	20 81       	ld	r18, Z
    13de:	01 c0       	rjmp	.+2      	; 0x13e2 <process_packet+0x88>
			}
			// 'W'   
			send_response(slave_id, cmd, addr, data);
			    
			} else if (cmd == 'R') {
				data = 0;
    13e0:	20 e0       	ldi	r18, 0x00	; 0
				if (addr < 16) { //    
					data = g_device_registers[addr];
				}
				// 'R'   
				send_response(slave_id, cmd, addr, data);
    13e2:	4f 2d       	mov	r20, r15
    13e4:	60 2f       	mov	r22, r16
    13e6:	81 2f       	mov	r24, r17
    13e8:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <send_response>
		}
	}


}
    13ec:	df 91       	pop	r29
    13ee:	cf 91       	pop	r28
    13f0:	1f 91       	pop	r17
    13f2:	0f 91       	pop	r16
    13f4:	ff 90       	pop	r15
    13f6:	ef 90       	pop	r14
    13f8:	08 95       	ret

000013fa <vProtocolTask>:

/**
 * @brief Protocol Task:  ->   ->  
 * vRxTask        .
 */
void vProtocolTask(void *pvParameters) {
    13fa:	cf 93       	push	r28
    13fc:	df 93       	push	r29
    13fe:	cd b7       	in	r28, 0x3d	; 61
    1400:	de b7       	in	r29, 0x3e	; 62
    1402:	61 97       	sbiw	r28, 0x11	; 17
    1404:	0f b6       	in	r0, 0x3f	; 63
    1406:	f8 94       	cli
    1408:	de bf       	out	0x3e, r29	; 62
    140a:	0f be       	out	0x3f, r0	; 63
    140c:	cd bf       	out	0x3d, r28	; 61
    uint8_t received_char;
    uint8_t packet_buffer[PROTOCOL_BUFFER_SIZE];
    uint8_t packet_index = 0;
    
    //   (IDLE: '$' , RECEIVING: '\n' )
    enum { STATE_IDLE, STATE_RECEIVING } state = STATE_IDLE;
    140e:	10 e0       	ldi	r17, 0x00	; 0
 * vRxTask        .
 */
void vProtocolTask(void *pvParameters) {
    uint8_t received_char;
    uint8_t packet_buffer[PROTOCOL_BUFFER_SIZE];
    uint8_t packet_index = 0;
    1410:	00 e0       	ldi	r16, 0x00	; 0
    1412:	03 c0       	rjmp	.+6      	; 0x141a <vProtocolTask+0x20>
                //  
                if (packet_index < PROTOCOL_BUFFER_SIZE) {
                    packet_buffer[packet_index++] = received_char;
                } else {
                    //  .   
                    state = STATE_IDLE;
    1414:	10 e0       	ldi	r17, 0x00	; 0
    1416:	01 c0       	rjmp	.+2      	; 0x141a <vProtocolTask+0x20>
                }
            } 
            else if (state == STATE_RECEIVING) {
                //  
                if (packet_index < PROTOCOL_BUFFER_SIZE) {
                    packet_buffer[packet_index++] = received_char;
    1418:	0f 2d       	mov	r16, r15
    //   (IDLE: '$' , RECEIVING: '\n' )
    enum { STATE_IDLE, STATE_RECEIVING } state = STATE_IDLE;

    while (1) {
        // 1. FreeRTOS    ( )
        if (xQueueReceive(xUartQueue, &received_char, portMAX_DELAY) == pdPASS) {
    141a:	20 e0       	ldi	r18, 0x00	; 0
    141c:	4f ef       	ldi	r20, 0xFF	; 255
    141e:	5f ef       	ldi	r21, 0xFF	; 255
    1420:	be 01       	movw	r22, r28
    1422:	6f 5f       	subi	r22, 0xFF	; 255
    1424:	7f 4f       	sbci	r23, 0xFF	; 255
    1426:	80 91 b0 04 	lds	r24, 0x04B0	; 0x8004b0 <xUartQueue>
    142a:	90 91 b1 04 	lds	r25, 0x04B1	; 0x8004b1 <xUartQueue+0x1>
    142e:	0e 94 3d 04 	call	0x87a	; 0x87a <xQueueGenericReceive>
    1432:	81 30       	cpi	r24, 0x01	; 1
    1434:	91 f7       	brne	.-28     	; 0x141a <vProtocolTask+0x20>
            
            if (state == STATE_IDLE) {
    1436:	11 11       	cpse	r17, r1
    1438:	07 c0       	rjmp	.+14     	; 0x1448 <vProtocolTask+0x4e>
                // '$' ( ) 
                if (received_char == '$') {
    143a:	89 81       	ldd	r24, Y+1	; 0x01
    143c:	84 32       	cpi	r24, 0x24	; 36
    143e:	69 f7       	brne	.-38     	; 0x141a <vProtocolTask+0x20>
                    packet_index = 0;
                    packet_buffer[packet_index++] = received_char;
    1440:	8a 83       	std	Y+2, r24	; 0x02
                    state = STATE_RECEIVING;
    1442:	11 e0       	ldi	r17, 0x01	; 1
            
            if (state == STATE_IDLE) {
                // '$' ( ) 
                if (received_char == '$') {
                    packet_index = 0;
                    packet_buffer[packet_index++] = received_char;
    1444:	01 e0       	ldi	r16, 0x01	; 1
    1446:	e9 cf       	rjmp	.-46     	; 0x141a <vProtocolTask+0x20>
                    state = STATE_RECEIVING;
                }
            } 
            else if (state == STATE_RECEIVING) {
    1448:	11 30       	cpi	r17, 0x01	; 1
    144a:	39 f7       	brne	.-50     	; 0x141a <vProtocolTask+0x20>
                //  
                if (packet_index < PROTOCOL_BUFFER_SIZE) {
    144c:	00 31       	cpi	r16, 0x10	; 16
    144e:	10 f7       	brcc	.-60     	; 0x1414 <vProtocolTask+0x1a>
                    packet_buffer[packet_index++] = received_char;
    1450:	ff 24       	eor	r15, r15
    1452:	f3 94       	inc	r15
    1454:	f0 0e       	add	r15, r16
    1456:	89 81       	ldd	r24, Y+1	; 0x01
    1458:	e2 e0       	ldi	r30, 0x02	; 2
    145a:	f0 e0       	ldi	r31, 0x00	; 0
    145c:	ec 0f       	add	r30, r28
    145e:	fd 1f       	adc	r31, r29
    1460:	e0 0f       	add	r30, r16
    1462:	f1 1d       	adc	r31, r1
    1464:	80 83       	st	Z, r24
                    state = STATE_IDLE;
                    continue;
                }

                // '\n' ( )  
                if (received_char == '\n') {
    1466:	8a 30       	cpi	r24, 0x0A	; 10
    1468:	b9 f6       	brne	.-82     	; 0x1418 <vProtocolTask+0x1e>
                    // Master   
                    process_packet(packet_buffer, packet_index);
    146a:	6f 2d       	mov	r22, r15
    146c:	ce 01       	movw	r24, r28
    146e:	02 96       	adiw	r24, 0x02	; 2
    1470:	0e 94 ad 09 	call	0x135a	; 0x135a <process_packet>
                }
            } 
            else if (state == STATE_RECEIVING) {
                //  
                if (packet_index < PROTOCOL_BUFFER_SIZE) {
                    packet_buffer[packet_index++] = received_char;
    1474:	0f 2d       	mov	r16, r15
                // '\n' ( )  
                if (received_char == '\n') {
                    // Master   
                    process_packet(packet_buffer, packet_index);
                    //    IDLE  
                    state = STATE_IDLE;
    1476:	10 e0       	ldi	r17, 0x00	; 0
    1478:	d0 cf       	rjmp	.-96     	; 0x141a <vProtocolTask+0x20>

0000147a <main>:
}


int main(void) {
    // UART  
    uart_init(BAUD);
    147a:	60 e8       	ldi	r22, 0x80	; 128
    147c:	75 e2       	ldi	r23, 0x25	; 37
    147e:	80 e0       	ldi	r24, 0x00	; 0
    1480:	90 e0       	ldi	r25, 0x00	; 0
    1482:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <uart_init>
    
    //  : 64 8(uint8_t)  
    //     
    xUartQueue = xQueueCreate(64, sizeof(uint8_t));
    1486:	40 e0       	ldi	r20, 0x00	; 0
    1488:	61 e0       	ldi	r22, 0x01	; 1
    148a:	80 e4       	ldi	r24, 0x40	; 64
    148c:	0e 94 81 03 	call	0x702	; 0x702 <xQueueGenericCreate>
    1490:	90 93 b1 04 	sts	0x04B1, r25	; 0x8004b1 <xUartQueue+0x1>
    1494:	80 93 b0 04 	sts	0x04B0, r24	; 0x8004b0 <xUartQueue>

    if (xUartQueue != NULL) {
    1498:	89 2b       	or	r24, r25
    149a:	d1 f0       	breq	.+52     	; 0x14d0 <main+0x56>
        // Rx Task  ( :       )
        xTaskCreate(
    149c:	e1 2c       	mov	r14, r1
    149e:	f1 2c       	mov	r15, r1
    14a0:	02 e0       	ldi	r16, 0x02	; 2
    14a2:	20 e0       	ldi	r18, 0x00	; 0
    14a4:	30 e0       	ldi	r19, 0x00	; 0
    14a6:	45 e5       	ldi	r20, 0x55	; 85
    14a8:	50 e0       	ldi	r21, 0x00	; 0
    14aa:	65 e0       	ldi	r22, 0x05	; 5
    14ac:	71 e0       	ldi	r23, 0x01	; 1
    14ae:	87 e6       	ldi	r24, 0x67	; 103
    14b0:	99 e0       	ldi	r25, 0x09	; 9
    14b2:	0e 94 67 06 	call	0xcce	; 0xcce <xTaskCreate>
            tskIDLE_PRIORITY + 2,
            NULL
        );

        // Protocol Task  (  :  )
        xTaskCreate(
    14b6:	01 e0       	ldi	r16, 0x01	; 1
    14b8:	20 e0       	ldi	r18, 0x00	; 0
    14ba:	30 e0       	ldi	r19, 0x00	; 0
    14bc:	49 eb       	ldi	r20, 0xB9	; 185
    14be:	50 e0       	ldi	r21, 0x00	; 0
    14c0:	6c e0       	ldi	r22, 0x0C	; 12
    14c2:	71 e0       	ldi	r23, 0x01	; 1
    14c4:	8d ef       	ldi	r24, 0xFD	; 253
    14c6:	99 e0       	ldi	r25, 0x09	; 9
    14c8:	0e 94 67 06 	call	0xcce	; 0xcce <xTaskCreate>
            tskIDLE_PRIORITY + 1,
            NULL
        );
        
        // FreeRTOS  
        vTaskStartScheduler();
    14cc:	0e 94 bb 06 	call	0xd76	; 0xd76 <vTaskStartScheduler>
    14d0:	ff cf       	rjmp	.-2      	; 0x14d0 <main+0x56>

000014d2 <__vector_18>:
volatile uint8_t rx_buffer[USART_RX_BUFFER_SIZE];
volatile uint8_t rx_head = 0;
volatile uint8_t rx_tail = 0;

//     (RX Complete)
ISR(USART_RX_vect) {
    14d2:	1f 92       	push	r1
    14d4:	0f 92       	push	r0
    14d6:	0f b6       	in	r0, 0x3f	; 63
    14d8:	0f 92       	push	r0
    14da:	11 24       	eor	r1, r1
    14dc:	2f 93       	push	r18
    14de:	3f 93       	push	r19
    14e0:	8f 93       	push	r24
    14e2:	9f 93       	push	r25
    14e4:	ef 93       	push	r30
    14e6:	ff 93       	push	r31
	uint8_t data = UDR0;
    14e8:	30 91 c6 00 	lds	r19, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
	uint8_t next_head = (rx_head + 1) % USART_RX_BUFFER_SIZE;
    14ec:	80 91 b3 04 	lds	r24, 0x04B3	; 0x8004b3 <rx_head>
    14f0:	90 e0       	ldi	r25, 0x00	; 0
    14f2:	01 96       	adiw	r24, 0x01	; 1
    14f4:	8f 73       	andi	r24, 0x3F	; 63
    14f6:	90 78       	andi	r25, 0x80	; 128
    14f8:	99 23       	and	r25, r25
    14fa:	24 f4       	brge	.+8      	; 0x1504 <__vector_18+0x32>
    14fc:	01 97       	sbiw	r24, 0x01	; 1
    14fe:	80 6c       	ori	r24, 0xC0	; 192
    1500:	9f 6f       	ori	r25, 0xFF	; 255
    1502:	01 96       	adiw	r24, 0x01	; 1

	//   
	if (next_head == rx_tail) {
    1504:	20 91 b2 04 	lds	r18, 0x04B2	; 0x8004b2 <rx_tail>
    1508:	28 17       	cp	r18, r24
    150a:	41 f0       	breq	.+16     	; 0x151c <__vector_18+0x4a>
		return;
	}

	rx_buffer[rx_head] = data;
    150c:	e0 91 b3 04 	lds	r30, 0x04B3	; 0x8004b3 <rx_head>
    1510:	f0 e0       	ldi	r31, 0x00	; 0
    1512:	ea 54       	subi	r30, 0x4A	; 74
    1514:	fb 4f       	sbci	r31, 0xFB	; 251
    1516:	30 83       	st	Z, r19
	rx_head = next_head;
    1518:	80 93 b3 04 	sts	0x04B3, r24	; 0x8004b3 <rx_head>
}
    151c:	ff 91       	pop	r31
    151e:	ef 91       	pop	r30
    1520:	9f 91       	pop	r25
    1522:	8f 91       	pop	r24
    1524:	3f 91       	pop	r19
    1526:	2f 91       	pop	r18
    1528:	0f 90       	pop	r0
    152a:	0f be       	out	0x3f, r0	; 63
    152c:	0f 90       	pop	r0
    152e:	1f 90       	pop	r1
    1530:	18 95       	reti

00001532 <__vector_19>:


//        (Data Register Empty)
ISR(USART_UDRE_vect) {
    1532:	1f 92       	push	r1
    1534:	0f 92       	push	r0
    1536:	0f b6       	in	r0, 0x3f	; 63
    1538:	0f 92       	push	r0
    153a:	11 24       	eor	r1, r1
    153c:	8f 93       	push	r24
    153e:	9f 93       	push	r25
    1540:	ef 93       	push	r30
    1542:	ff 93       	push	r31
	if (tx_head == tx_tail) {
    1544:	90 91 b5 04 	lds	r25, 0x04B5	; 0x8004b5 <tx_head>
    1548:	80 91 b4 04 	lds	r24, 0x04B4	; 0x8004b4 <tx_tail>
    154c:	98 13       	cpse	r25, r24
    154e:	06 c0       	rjmp	.+12     	; 0x155c <__vector_19+0x2a>
		//    UDRE  .
		UCSR0B &= ~(1 << UDRIE0);
    1550:	e1 ec       	ldi	r30, 0xC1	; 193
    1552:	f0 e0       	ldi	r31, 0x00	; 0
    1554:	80 81       	ld	r24, Z
    1556:	8f 7d       	andi	r24, 0xDF	; 223
    1558:	80 83       	st	Z, r24
		//   TX Complete ISR .
		return;
    155a:	14 c0       	rjmp	.+40     	; 0x1584 <__vector_19+0x52>
	}

	//   
	UDR0 = tx_buffer[tx_tail];
    155c:	e0 91 b4 04 	lds	r30, 0x04B4	; 0x8004b4 <tx_tail>
    1560:	f0 e0       	ldi	r31, 0x00	; 0
    1562:	ea 50       	subi	r30, 0x0A	; 10
    1564:	fb 4f       	sbci	r31, 0xFB	; 251
    1566:	80 81       	ld	r24, Z
    1568:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
	tx_tail = (tx_tail + 1) % USART_TX_BUFFER_SIZE;
    156c:	80 91 b4 04 	lds	r24, 0x04B4	; 0x8004b4 <tx_tail>
    1570:	90 e0       	ldi	r25, 0x00	; 0
    1572:	01 96       	adiw	r24, 0x01	; 1
    1574:	90 78       	andi	r25, 0x80	; 128
    1576:	99 23       	and	r25, r25
    1578:	1c f4       	brge	.+6      	; 0x1580 <__vector_19+0x4e>
    157a:	01 97       	sbiw	r24, 0x01	; 1
    157c:	9f 6f       	ori	r25, 0xFF	; 255
    157e:	01 96       	adiw	r24, 0x01	; 1
    1580:	80 93 b4 04 	sts	0x04B4, r24	; 0x8004b4 <tx_tail>
}
    1584:	ff 91       	pop	r31
    1586:	ef 91       	pop	r30
    1588:	9f 91       	pop	r25
    158a:	8f 91       	pop	r24
    158c:	0f 90       	pop	r0
    158e:	0f be       	out	0x3f, r0	; 63
    1590:	0f 90       	pop	r0
    1592:	1f 90       	pop	r1
    1594:	18 95       	reti

00001596 <__vector_20>:

//     (TX Complete) - RS-485   
ISR(USART_TX_vect) {
    1596:	1f 92       	push	r1
    1598:	0f 92       	push	r0
    159a:	0f b6       	in	r0, 0x3f	; 63
    159c:	0f 92       	push	r0
    159e:	11 24       	eor	r1, r1
    15a0:	8f 93       	push	r24
    15a2:	9f 93       	push	r25
	//      .
	//     (UDRE ISR   UDR0  ) 
	if (tx_head == tx_tail) {
    15a4:	90 91 b5 04 	lds	r25, 0x04B5	; 0x8004b5 <tx_head>
    15a8:	80 91 b4 04 	lds	r24, 0x04B4	; 0x8004b4 <tx_tail>
    15ac:	98 13       	cpse	r25, r24
    15ae:	03 c0       	rjmp	.+6      	; 0x15b6 <__vector_20+0x20>
		//    , RS-485   .
		//    (DE=LOW, ~RE=LOW)
		RS485_PORT &= ~((1 << RS485_DE_PIN) | (1 << RS485_RE_PIN));
    15b0:	8b b1       	in	r24, 0x0b	; 11
    15b2:	83 7f       	andi	r24, 0xF3	; 243
    15b4:	8b b9       	out	0x0b, r24	; 11
	}

}
    15b6:	9f 91       	pop	r25
    15b8:	8f 91       	pop	r24
    15ba:	0f 90       	pop	r0
    15bc:	0f be       	out	0x3f, r0	; 63
    15be:	0f 90       	pop	r0
    15c0:	1f 90       	pop	r1
    15c2:	18 95       	reti

000015c4 <uart_init>:
// 4. UART/RS-485  
// -----------------------------------------------------------

void uart_init(uint32_t baud) {
	//  
	UBRR0H = (uint8_t)(UBRR_VALUE >> 8);
    15c4:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
	UBRR0L = (uint8_t)UBRR_VALUE;
    15c8:	87 e6       	ldi	r24, 0x67	; 103
    15ca:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
	
	// RX/TX, RXCIE0 
	// TXCIE0 (TX Complete Interrupt Enable)  
	UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0) | (1 << TXCIE0);
    15ce:	88 ed       	ldi	r24, 0xD8	; 216
    15d0:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
	
	// 8N1 
	UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
    15d4:	86 e0       	ldi	r24, 0x06	; 6
    15d6:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
	
	// RS-485     
	RS485_DDR |= (1 << RS485_DE_PIN) | (1 << RS485_RE_PIN);
    15da:	8a b1       	in	r24, 0x0a	; 10
    15dc:	8c 60       	ori	r24, 0x0C	; 12
    15de:	8a b9       	out	0x0a, r24	; 10
	
	//  :   (DE=LOW, ~RE=LOW)
	RS485_PORT &= ~((1 << RS485_DE_PIN) | (1 << RS485_RE_PIN));
    15e0:	8b b1       	in	r24, 0x0b	; 11
    15e2:	83 7f       	andi	r24, 0xF3	; 243
    15e4:	8b b9       	out	0x0b, r24	; 11

	// TXC    (1  ).
	UCSR0A |= (1 << TXC0);
    15e6:	e0 ec       	ldi	r30, 0xC0	; 192
    15e8:	f0 e0       	ldi	r31, 0x00	; 0
    15ea:	80 81       	ld	r24, Z
    15ec:	80 64       	ori	r24, 0x40	; 64
    15ee:	80 83       	st	Z, r24
    15f0:	08 95       	ret

000015f2 <uart_tx>:
}

void uart_tx(uint8_t data) {
    15f2:	cf 93       	push	r28
    15f4:	c8 2f       	mov	r28, r24
	uint8_t next_head;
	
	// 1.    (     TX  )
	// (DE=HIGH, ~RE=HIGH)
	RS485_PORT |= (1 << RS485_DE_PIN) | (1 << RS485_RE_PIN);
    15f6:	8b b1       	in	r24, 0x0b	; 11
    15f8:	8c 60       	ori	r24, 0x0C	; 12
    15fa:	8b b9       	out	0x0b, r24	; 11
	
	// 2.    (Non-blocking: FreeRTOS Task Block)
	while (1) {
		next_head = (tx_head + 1) % USART_TX_BUFFER_SIZE;
    15fc:	80 91 b5 04 	lds	r24, 0x04B5	; 0x8004b5 <tx_head>
    1600:	90 e0       	ldi	r25, 0x00	; 0
    1602:	01 96       	adiw	r24, 0x01	; 1
    1604:	90 78       	andi	r25, 0x80	; 128
    1606:	99 23       	and	r25, r25
    1608:	1c f4       	brge	.+6      	; 0x1610 <uart_tx+0x1e>
    160a:	01 97       	sbiw	r24, 0x01	; 1
    160c:	9f 6f       	ori	r25, 0xFF	; 255
    160e:	01 96       	adiw	r24, 0x01	; 1
		
		if (next_head != tx_tail) {
    1610:	90 91 b4 04 	lds	r25, 0x04B4	; 0x8004b4 <tx_tail>
    1614:	89 13       	cpse	r24, r25
    1616:	05 c0       	rjmp	.+10     	; 0x1622 <uart_tx+0x30>
			break; //     
		}
		
		//   , Task  Block CPU 
		// 1( 1ms)   Task UDRE ISR   
		vTaskDelay(pdMS_TO_TICKS(1));
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	90 e0       	ldi	r25, 0x00	; 0
    161c:	0e 94 17 08 	call	0x102e	; 0x102e <vTaskDelay>
	}
    1620:	ed cf       	rjmp	.-38     	; 0x15fc <uart_tx+0xa>

	tx_buffer[tx_head] = data;
    1622:	e0 91 b5 04 	lds	r30, 0x04B5	; 0x8004b5 <tx_head>
    1626:	f0 e0       	ldi	r31, 0x00	; 0
    1628:	ea 50       	subi	r30, 0x0A	; 10
    162a:	fb 4f       	sbci	r31, 0xFB	; 251
    162c:	c0 83       	st	Z, r28
	tx_head = next_head;
    162e:	80 93 b5 04 	sts	0x04B5, r24	; 0x8004b5 <tx_head>
	
	// 3. UDRE   ( )
	UCSR0B |= (1 << UDRIE0);
    1632:	e1 ec       	ldi	r30, 0xC1	; 193
    1634:	f0 e0       	ldi	r31, 0x00	; 0
    1636:	80 81       	ld	r24, Z
    1638:	80 62       	ori	r24, 0x20	; 32
    163a:	80 83       	st	Z, r24
}
    163c:	cf 91       	pop	r28
    163e:	08 95       	ret

00001640 <uart_rx>:

uint8_t uart_rx() {
	// RX   , Task Block    
	while (rx_head == rx_tail) {
    1640:	04 c0       	rjmp	.+8      	; 0x164a <uart_rx+0xa>
		// FreeRTOS  Polling  Task Block/Delay .
		//   1ms Delay . (   Semaphore Task Notification )
		vTaskDelay(pdMS_TO_TICKS(1));
    1642:	81 e0       	ldi	r24, 0x01	; 1
    1644:	90 e0       	ldi	r25, 0x00	; 0
    1646:	0e 94 17 08 	call	0x102e	; 0x102e <vTaskDelay>
	UCSR0B |= (1 << UDRIE0);
}

uint8_t uart_rx() {
	// RX   , Task Block    
	while (rx_head == rx_tail) {
    164a:	90 91 b3 04 	lds	r25, 0x04B3	; 0x8004b3 <rx_head>
    164e:	80 91 b2 04 	lds	r24, 0x04B2	; 0x8004b2 <rx_tail>
    1652:	98 17       	cp	r25, r24
    1654:	b1 f3       	breq	.-20     	; 0x1642 <uart_rx+0x2>
		// FreeRTOS  Polling  Task Block/Delay .
		//   1ms Delay . (   Semaphore Task Notification )
		vTaskDelay(pdMS_TO_TICKS(1));
	}
	uint8_t data = rx_buffer[rx_tail];
    1656:	e0 91 b2 04 	lds	r30, 0x04B2	; 0x8004b2 <rx_tail>
    165a:	f0 e0       	ldi	r31, 0x00	; 0
    165c:	ea 54       	subi	r30, 0x4A	; 74
    165e:	fb 4f       	sbci	r31, 0xFB	; 251
    1660:	80 81       	ld	r24, Z
	rx_tail = (rx_tail + 1) % USART_RX_BUFFER_SIZE;
    1662:	20 91 b2 04 	lds	r18, 0x04B2	; 0x8004b2 <rx_tail>
    1666:	30 e0       	ldi	r19, 0x00	; 0
    1668:	2f 5f       	subi	r18, 0xFF	; 255
    166a:	3f 4f       	sbci	r19, 0xFF	; 255
    166c:	2f 73       	andi	r18, 0x3F	; 63
    166e:	30 78       	andi	r19, 0x80	; 128
    1670:	33 23       	and	r19, r19
    1672:	34 f4       	brge	.+12     	; 0x1680 <uart_rx+0x40>
    1674:	21 50       	subi	r18, 0x01	; 1
    1676:	31 09       	sbc	r19, r1
    1678:	20 6c       	ori	r18, 0xC0	; 192
    167a:	3f 6f       	ori	r19, 0xFF	; 255
    167c:	2f 5f       	subi	r18, 0xFF	; 255
    167e:	3f 4f       	sbci	r19, 0xFF	; 255
    1680:	20 93 b2 04 	sts	0x04B2, r18	; 0x8004b2 <rx_tail>
	return data;
}
    1684:	08 95       	ret

00001686 <memcpy>:
    1686:	fb 01       	movw	r30, r22
    1688:	dc 01       	movw	r26, r24
    168a:	02 c0       	rjmp	.+4      	; 0x1690 <memcpy+0xa>
    168c:	01 90       	ld	r0, Z+
    168e:	0d 92       	st	X+, r0
    1690:	41 50       	subi	r20, 0x01	; 1
    1692:	50 40       	sbci	r21, 0x00	; 0
    1694:	d8 f7       	brcc	.-10     	; 0x168c <memcpy+0x6>
    1696:	08 95       	ret

00001698 <_exit>:
    1698:	f8 94       	cli

0000169a <__stop_program>:
    169a:	ff cf       	rjmp	.-2      	; 0x169a <__stop_program>
